"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("../client");
const config_1 = require("../config");
const layout_1 = require("../layout");
const fixednum_1 = require("../fixednum");
const utils_1 = require("../utils");
function setUp(client, entropyGroupKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const entropyGroup = yield client.getEntropyGroup(entropyGroupKey);
        yield entropyGroup.loadRootBanks(client.connection);
        const entropyAccounts = yield client.getAllEntropyAccounts(entropyGroup, undefined, true);
        const entropyCache = yield entropyGroup.loadCache(client.connection);
        const perpMarkets = yield Promise.all(entropyGroup.perpMarkets.map((pmi, i) => pmi.isEmpty()
            ? undefined
            : client.getPerpMarket(pmi.perpMarket, entropyGroup.tokens[i].decimals, entropyGroup.tokens[layout_1.QUOTE_INDEX].decimals)));
        return { entropyGroup, entropyCache, entropyAccounts, perpMarkets };
    });
}
function checkSumOfBasePositions(groupConfig, entropyCache, entropyAccounts, perpMarkets) {
    var _a;
    let totalBase = utils_1.ZERO_BN;
    let totalQuote = fixednum_1.ZERO_I80F48;
    for (let i = 0; i < layout_1.QUOTE_INDEX; i++) {
        if (perpMarkets[i] === undefined) {
            continue;
        }
        const perpMarket = perpMarkets[i];
        let sumOfAllBasePositions = utils_1.ZERO_BN;
        let absBasePositions = utils_1.ZERO_BN;
        let sumQuote = perpMarket.feesAccrued;
        const perpMarketCache = entropyCache.perpMarketCache[i];
        for (const entropyAccount of entropyAccounts) {
            const perpAccount = entropyAccount.perpAccounts[i];
            sumOfAllBasePositions = sumOfAllBasePositions.add(perpAccount.basePosition);
            absBasePositions = absBasePositions.add(perpAccount.basePosition.abs());
            sumQuote = sumQuote.add(perpAccount.getQuotePosition(perpMarketCache));
        }
        console.log(`Market: ${(_a = (0, config_1.getPerpMarketByIndex)(groupConfig, i)) === null || _a === void 0 ? void 0 : _a.name}
      Sum Base Pos: ${sumOfAllBasePositions.toString()}
      Sum Abs Base Pos ${absBasePositions.toString()}
      Open Interest: ${perpMarket.openInterest.toString()}
      Sum Quote: ${sumQuote.toString()}\n`);
        totalBase = totalBase.add(sumOfAllBasePositions);
        totalQuote = totalQuote.add(sumQuote);
    }
    console.log(`Total Base: ${totalBase.toString()}\nTotal Quote: ${totalQuote.toString()}`);
}
function checkSumOfNetDeposit(groupConfig, connection, entropyGroup, entropyCache, entropyAccounts) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        for (let i = 0; i < entropyGroup.tokens.length; i++) {
            if (entropyGroup.tokens[i].mint.equals(utils_1.zeroKey)) {
                continue;
            }
            console.log('======');
            console.log((_a = (0, config_1.getTokenByMint)(groupConfig, entropyGroup.tokens[i].mint)) === null || _a === void 0 ? void 0 : _a.symbol);
            console.log('deposit index', entropyCache.rootBankCache[i].depositIndex.toString());
            console.log('borrow index', entropyCache.rootBankCache[i].borrowIndex.toString());
            const sumOfNetDepositsAcrossMAs = entropyAccounts.reduce((sum, entropyAccount) => {
                return sum.add(entropyAccount.getNet(entropyCache.rootBankCache[i], i));
            }, fixednum_1.ZERO_I80F48);
            console.log('sumOfNetDepositsAcrossMAs:', sumOfNetDepositsAcrossMAs.toString());
            let vaultAmount = fixednum_1.ZERO_I80F48;
            const rootBank = entropyGroup.rootBankAccounts[i];
            if (rootBank) {
                const nodeBanks = rootBank.nodeBankAccounts;
                const vaults = yield Promise.all(nodeBanks.map((n) => connection.getTokenAccountBalance(n.vault)));
                const sumOfNetDepositsAcrossNodes = nodeBanks.reduce((sum, nodeBank) => {
                    return sum.add(nodeBank.deposits.mul(entropyCache.rootBankCache[i].depositIndex));
                }, fixednum_1.ZERO_I80F48);
                const sumOfNetBorrowsAcrossNodes = nodeBanks.reduce((sum, nodeBank) => {
                    return sum.add(nodeBank.borrows.mul(entropyCache.rootBankCache[i].borrowIndex));
                }, fixednum_1.ZERO_I80F48);
                console.log('sumOfNetDepositsAcrossNodes:', sumOfNetDepositsAcrossNodes.toString());
                console.log('sumOfNetBorrowsAcrossNodes:', sumOfNetBorrowsAcrossNodes.toString());
                for (const vault of vaults) {
                    // @ts-ignore
                    vaultAmount = vaultAmount.add(fixednum_1.I80F48.fromString(vault.value.amount));
                }
                console.log('vaultAmount:', vaultAmount.toString());
                console.log('nodesDiff:', vaultAmount
                    .sub(sumOfNetDepositsAcrossNodes)
                    .add(sumOfNetBorrowsAcrossNodes)
                    .toString());
            }
            console.log('Diff', vaultAmount.sub(sumOfNetDepositsAcrossMAs).toString());
        }
    });
}
function sanityCheck(connection, groupConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = new client_1.EntropyClient(connection, groupConfig.entropyProgramId);
        const { entropyGroup, entropyCache, entropyAccounts, perpMarkets } = yield setUp(client, groupConfig.publicKey);
        checkSumOfBasePositions(groupConfig, entropyCache, entropyAccounts, perpMarkets);
        yield checkSumOfNetDeposit(groupConfig, connection, entropyGroup, entropyCache, entropyAccounts);
    });
}
exports.default = sanityCheck;
//# sourceMappingURL=sanityCheck.js.map