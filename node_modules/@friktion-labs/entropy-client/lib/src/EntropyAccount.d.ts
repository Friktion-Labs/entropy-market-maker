import { Market, OpenOrders } from '@project-serum/serum';
import { Connection, PublicKey } from '@solana/web3.js';
import { I80F48 } from './fixednum';
import { EntropyCache, MetaData, RootBankCache } from './layout';
import RootBank from './RootBank';
import BN from 'bn.js';
import EntropyGroup from './EntropyGroup';
import PerpAccount from './PerpAccount';
import { GroupConfig, PerpTriggerOrder } from '.';
import PerpMarket from './PerpMarket';
import { Order } from '@project-serum/serum/lib/market';
export default class EntropyAccount {
    publicKey: PublicKey;
    metaData: MetaData;
    entropyGroup: PublicKey;
    owner: PublicKey;
    inMarginBasket: boolean[];
    numInMarginBasket: number;
    deposits: I80F48[];
    borrows: I80F48[];
    spotOpenOrders: PublicKey[];
    spotOpenOrdersAccounts: (OpenOrders | undefined)[];
    perpAccounts: PerpAccount[];
    orderMarket: number[];
    orderSide: string[];
    orders: BN[];
    clientOrderIds: BN[];
    msrmAmount: BN;
    beingLiquidated: boolean;
    isBankrupt: boolean;
    info: number[];
    advancedOrdersKey: PublicKey;
    advancedOrders: {
        perpTrigger?: PerpTriggerOrder;
    }[];
    constructor(publicKey: PublicKey, decoded: any);
    get name(): string;
    getLiquidationPrice(entropyGroup: EntropyGroup, entropyCache: EntropyCache, oracleIndex: number): I80F48 | undefined;
    hasAnySpotOrders(): boolean;
    reload(connection: Connection, dexProgramId?: PublicKey | undefined): Promise<EntropyAccount>;
    reloadFromSlot(connection: Connection, lastSlot?: number, dexProgramId?: PublicKey | undefined): Promise<EntropyAccount>;
    loadSpotOrdersForMarket(connection: Connection, market: Market, marketIndex: number): Promise<Order[]>;
    loadOpenOrders(connection: Connection, serumDexPk: PublicKey): Promise<(OpenOrders | undefined)[]>;
    loadAdvancedOrders(connection: Connection): Promise<{
        perpTrigger?: PerpTriggerOrder;
    }[]>;
    getNativeDeposit(rootBank: RootBank | RootBankCache, tokenIndex: number): I80F48;
    getNativeBorrow(rootBank: RootBank | RootBankCache, tokenIndex: number): I80F48;
    getUiDeposit(rootBank: RootBank | RootBankCache, entropyGroup: EntropyGroup, tokenIndex: number): I80F48;
    getUiBorrow(rootBank: RootBank | RootBankCache, entropyGroup: EntropyGroup, tokenIndex: number): I80F48;
    getSpotVal(entropyGroup: any, entropyCache: any, index: any, assetWeight: any): I80F48;
    getAssetsVal(entropyGroup: EntropyGroup, entropyCache: EntropyCache, healthType?: HealthType): I80F48;
    getLiabsVal(entropyGroup: EntropyGroup, entropyCache: EntropyCache, healthType?: HealthType): I80F48;
    getNativeLiabsVal(entropyGroup: EntropyGroup, entropyCache: EntropyCache, healthType?: HealthType): I80F48;
    /**
     * deposits - borrows in native terms
     */
    getNet(bankCache: RootBankCache, tokenIndex: number): I80F48;
    /**
     * Take health components and return the assets and liabs weighted
     */
    getWeightedAssetsLiabsVals(entropyGroup: EntropyGroup, entropyCache: EntropyCache, spot: I80F48[], perps: I80F48[], quote: I80F48, healthType?: HealthType): {
        assets: I80F48;
        liabs: I80F48;
    };
    getHealthFromComponents(entropyGroup: EntropyGroup, entropyCache: EntropyCache, spot: I80F48[], perps: I80F48[], quote: I80F48, healthType: HealthType): I80F48;
    getHealthFromComponentsUnweighted(mangoGroup: EntropyGroup, mangoCache: EntropyCache, spot: I80F48[], perps: I80F48[], quote: I80F48): I80F48;
    getHealthsFromComponents(entropyGroup: EntropyGroup, entropyCache: EntropyCache, spot: I80F48[], perps: I80F48[], quote: I80F48, healthType: HealthType): {
        spot: I80F48;
        perp: I80F48;
    };
    /**
     * Amount of native quote currency available to expand your position in this market
     */
    getMarketMarginAvailable(entropyGroup: EntropyGroup, entropyCache: EntropyCache, marketIndex: number, marketType: 'spot' | 'perp'): I80F48;
    /**
     * Get token amount available to withdraw without borrowing.
     */
    getAvailableBalance(entropyGroup: EntropyGroup, entropyCache: EntropyCache, tokenIndex: number): I80F48;
    /**
     * Return the spot, perps and quote currency values after adjusting for
     * worst case open orders scenarios. These values are not adjusted for health
     * type
     * @param entropyGroup
     * @param entropyCache
     */
    getHealthComponents(entropyGroup: EntropyGroup, entropyCache: EntropyCache): {
        spot: I80F48[];
        perps: I80F48[];
        quote: I80F48;
    };
    getHealth(entropyGroup: EntropyGroup, entropyCache: EntropyCache, healthType: HealthType): I80F48;
    getHealthUnweighted(mangoGroup: EntropyGroup, mangoCache: EntropyCache): I80F48;
    getHealthRatio(entropyGroup: EntropyGroup, entropyCache: EntropyCache, healthType: HealthType): I80F48;
    computeValue(entropyGroup: EntropyGroup, entropyCache: EntropyCache): I80F48;
    getLeverage(entropyGroup: EntropyGroup, entropyCache: EntropyCache): I80F48;
    getMaxLeverageForMarket(entropyGroup: EntropyGroup, entropyCache: EntropyCache, marketIndex: number, market: Market | PerpMarket, side: 'buy' | 'sell', price: I80F48): {
        max: I80F48;
        uiDepositVal: I80F48;
        deposits: I80F48;
        uiBorrowVal: I80F48;
        borrows: I80F48;
    };
    getMaxWithBorrowForToken(entropyGroup: EntropyGroup, entropyCache: EntropyCache, tokenIndex: number): I80F48;
    isLiquidatable(entropyGroup: EntropyGroup, entropyCache: EntropyCache): boolean;
    toPrettyString(groupConfig: GroupConfig, entropyGroup: EntropyGroup, cache: EntropyCache): string;
    /**
     * Get all the open orders using only info in EntropyAccount; Does not contain
     * information about the size of the order.
     */
    getPerpOpenOrders(): {
        marketIndex: number;
        price: BN;
        side: string;
    }[];
    /**
     * Return the open orders keys in basket and replace open orders not in basket with zero key
     */
    getOpenOrdersKeysInBasket(): PublicKey[];
    /**
     *  Return the current position for the market at `marketIndex` in UI units
     *  e.g. if you buy 1 BTC in the UI, you're buying 1,000,000 native BTC,
     *  10,000 BTC-PERP contracts and exactly 1 BTC in UI
     *  Find the marketIndex in the ids.json list of perp markets
     */
    getPerpPositionUi(marketIndex: number, perpMarket: PerpMarket): number;
    /**
     *  Return the current position for the market at `marketIndex` in UI units
     *  e.g. if you buy 1 BTC in the UI, you're buying 1,000,000 native BTC,
     *  10,000 BTC-PERP contracts and exactly 1 BTC in UI
     *  Find the marketIndex in the ids.json list of perp markets
     */
    getBasePositionUiWithGroup(marketIndex: number, group: EntropyGroup): number;
    /**
     * Return the equity in standard UI numbers. E.g. if equity is $100, this returns 100
     */
    getEquityUi(entropyGroup: EntropyGroup, entropyCache: EntropyCache): number;
    /**
     * This is the init health divided by quote decimals
     */
    getCollateralValueUi(entropyGroup: EntropyGroup, entropyCache: EntropyCache): number;
}
export declare type HealthType = 'Init' | 'Maint';
//# sourceMappingURL=EntropyAccount.d.ts.map