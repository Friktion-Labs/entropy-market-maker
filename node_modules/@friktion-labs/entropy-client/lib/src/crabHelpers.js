#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCrabDelta = exports.CRAB_PUBKEY = void 0;
// TODO put node banks and vaults inside the GroupConfig
const web3_js_1 = require("@solana/web3.js");
const config_1 = require("./config");
const client_1 = require("./client");
const utils_1 = require("./utils");
const layout_1 = require("./layout");
const bn_js_1 = require("bn.js");
const cli_1 = require("./cli");
exports.CRAB_PUBKEY = 'VKH3Tf7yAgxU5JKkuU7HLmrYCvnGM2LKsPL9bvgRHq3';
/* Gets the midpoint of any given market*/
function getMidpoint(symbol, entropyGroup, groupConfig, connection, entropyCache, impactQuantity) {
    return __awaiter(this, void 0, void 0, function* () {
        const IMPACT_QUANTITY = new bn_js_1.BN(10000);
        const perpMarketConfig = (0, config_1.getMarketByBaseSymbolAndKind)(groupConfig, symbol, 'perp');
        const perpMarket = yield entropyGroup.loadPerpMarket(connection, perpMarketConfig.marketIndex, perpMarketConfig.baseDecimals, perpMarketConfig.quoteDecimals);
        const oraclePrice = entropyCache.priceCache[perpMarketConfig.marketIndex].price;
        const bids = yield perpMarket.loadBids(connection);
        const asks = yield perpMarket.loadAsks(connection);
        const bid = bids.getImpactPriceUi(IMPACT_QUANTITY) || oraclePrice.toNumber();
        const ask = asks.getImpactPriceUi(IMPACT_QUANTITY) || oraclePrice.toNumber();
        return (bid + ask) / 2;
    });
}
/*This function calculates the net delta exposure of the Crab Volt by taking the base position of BTC*/
function getCrabDelta(symbol, conn, pubkey = exports.CRAB_PUBKEY) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = (0, cli_1.readConfig)(__dirname + '/ids.json');
        const symbolSq = symbol + "^2";
        // Establish connection, gather metadata, caches, and configs
        const groupConfig = config.getGroupWithName('mainnet.2');
        const connection = conn;
        const client = new client_1.EntropyClient(connection, groupConfig.entropyProgramId);
        const entropyGroup = yield client.getEntropyGroup(groupConfig.publicKey);
        const entropyAccount = yield client.getEntropyAccount(new web3_js_1.PublicKey(pubkey), entropyGroup.dexProgramId);
        const entropyCache = yield entropyGroup.loadCache(connection);
        const perpMid = yield getMidpoint(symbol, entropyGroup, groupConfig, connection, entropyCache, 10000);
        const sqMid = yield getMidpoint(symbolSq, entropyGroup, groupConfig, connection, entropyCache, 10000);
        console.log(perpMid, sqMid);
        const quoteAdj = new bn_js_1.BN(10).pow(new bn_js_1.BN(entropyGroup.tokens[layout_1.QUOTE_INDEX].decimals));
        const equity = entropyAccount.computeValue(entropyGroup, entropyCache).toNumber();
        console.log("Crab Account Equity: ", equity);
        const sqMarketIndex = (0, utils_1.throwUndefined)((0, config_1.getPerpMarketByBaseSymbol)(groupConfig, symbolSq)).marketIndex;
        const perpMarketIndex = (0, utils_1.throwUndefined)((0, config_1.getPerpMarketByBaseSymbol)(groupConfig, symbol)).marketIndex;
        const sqBase = entropyAccount.getBasePositionUiWithGroup(sqMarketIndex, entropyGroup);
        const base = entropyAccount.getBasePositionUiWithGroup(perpMarketIndex, entropyGroup);
        const delta = (sqBase * sqMid * 2 + base * perpMid) / equity;
        console.log("Delta: ", delta);
        return delta;
    });
}
exports.getCrabDelta = getCrabDelta;
// export async function getTrades() {
//     const config = readConfig(__dirname+'/ids.json' as string);
//     const groupConfig = config.getGroupWithName(
//         'mainnet.2' as string,
//     ) as GroupConfig;
//     const connection = openConnection(config, groupConfig.cluster);
//     const client = new EntropyClient(connection, groupConfig.entropyProgramId);
//     const entropyGroup = await client.getEntropyGroup(groupConfig.publicKey);
//     const perpMarket = entropyGroup.perpMarkets[0];
//     const btcMarket = getPerpMarketByIndex(groupConfig, 0) as PerpMarketConfig;
//     const pm = await client.getPerpMarket(
//         perpMarket.perpMarket,
//         btcMarket.baseDecimals,
//         btcMarket.quoteDecimals,
//     );
//     const fills = await pm.loadFills(connection);
//     console.log(fills);
//     console.log(fills.length);
// }
// getCrabDelta("BTC");
//# sourceMappingURL=crabHelpers.js.map