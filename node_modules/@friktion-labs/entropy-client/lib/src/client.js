"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntropyClient = exports.getUnixTs = void 0;
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = __importDefault(require("bn.js"));
const utils_1 = require("./utils");
const layout_1 = require("./layout");
const EntropyAccount_1 = __importDefault(require("./EntropyAccount"));
const PerpMarket_1 = __importDefault(require("./PerpMarket"));
const instruction_1 = require("./instruction");
const serum_1 = require("@project-serum/serum");
const fixednum_1 = require("./fixednum");
const book_1 = require("./book");
const token_instructions_1 = require("@project-serum/serum/lib/token-instructions");
const spl_token_1 = require("@solana/spl-token");
const EntropyGroup_1 = __importDefault(require("./EntropyGroup"));
const _1 = require(".");
const instruction_2 = require("./instruction");
const getUnixTs = () => {
    return new Date().getTime() / 1000;
};
exports.getUnixTs = getUnixTs;
/**
 * A class for interacting with the Entropy V3 Program
 *
 * @param connection A solana web.js Connection object
 * @param programId The PublicKey of the Entropy V3 Program
 * @param opts An object used to configure the EntropyClient. Accepts a postSendTxCallback
 */
class EntropyClient {
    constructor(connection, programId, opts = {}) {
        this.connection = connection;
        this.programId = programId;
        this.lastSlot = 0;
        this.recentBlockhash = '';
        this.recentBlockhashTime = 0;
        this.maxStoredBlockhashes = (opts === null || opts === void 0 ? void 0 : opts.maxStoredBlockhashes) || 7;
        this.blockhashCommitment = (opts === null || opts === void 0 ? void 0 : opts.blockhashCommitment) || 'confirmed';
        this.timeout = (opts === null || opts === void 0 ? void 0 : opts.timeout) || 60000;
        if (opts.postSendTxCallback) {
            this.postSendTxCallback = opts.postSendTxCallback;
        }
        // console.log("Program Id from client.ts")
    }
    sendTransactions(transactions, payer, additionalSigners, timeout = 60000, confirmLevel = 'confirmed') {
        return __awaiter(this, void 0, void 0, function* () {
            return yield Promise.all(transactions.map((tx) => this.sendTransaction(tx, payer, additionalSigners, timeout, confirmLevel)));
        });
    }
    signTransaction({ transaction, payer, signers }) {
        return __awaiter(this, void 0, void 0, function* () {
            const now = (0, exports.getUnixTs)();
            let blockhash;
            // Get new blockhash if stored blockhash more than 70 seconds old
            if (this.recentBlockhashTime && now < this.recentBlockhashTime + 70) {
                blockhash = this.recentBlockhash;
            }
            else {
                blockhash = (yield this.connection.getRecentBlockhash('confirmed')).blockhash;
            }
            transaction.recentBlockhash = blockhash;
            transaction.setSigners(payer.publicKey, ...signers.map((s) => s.publicKey));
            if (signers.length > 0) {
                transaction.partialSign(...signers);
            }
            if (payer === null || payer === void 0 ? void 0 : payer.connected) {
                console.log(new Date().toISOString(), 'signing as wallet', payer.publicKey);
                return yield payer.signTransaction(transaction);
            }
            else {
                transaction.sign(...[payer].concat(signers));
            }
        });
    }
    signTransactions({ transactionsAndSigners, payer, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const now = (0, exports.getUnixTs)();
            let blockhash;
            // Get new blockhash if stored blockhash more than 70 seconds old
            if (this.recentBlockhashTime && now < this.recentBlockhashTime + 70) {
                blockhash = this.recentBlockhash;
            }
            else {
                blockhash = (yield this.connection.getRecentBlockhash('confirmed')).blockhash;
            }
            transactionsAndSigners.forEach(({ transaction, signers = [] }) => {
                transaction.recentBlockhash = blockhash;
                transaction.setSigners(payer.publicKey, ...signers.map((s) => s.publicKey));
                if ((signers === null || signers === void 0 ? void 0 : signers.length) > 0) {
                    transaction.partialSign(...signers);
                }
            });
            if (!(payer instanceof web3_js_1.Account)) {
                return yield payer.signAllTransactions(transactionsAndSigners.map(({ transaction }) => transaction));
            }
            else {
                transactionsAndSigners.forEach(({ transaction, signers }) => {
                    // @ts-ignore
                    transaction.sign(...[payer].concat(signers));
                });
            }
        });
    }
    // TODO - switch Account to Keypair and switch off setSigners due to deprecated
    /**
     * Send a transaction using the Solana Web3.js connection on the entropy client
     *
     * @param transaction
     * @param payer
     * @param additionalSigners
     * @param timeout Retries sending the transaction and trying to confirm it until the given timeout. Defaults to 60000ms. Passing null will disable the transaction confirmation check and always return success.
     */
    sendTransaction(transaction, payer, additionalSigners, timeout = 60000, confirmLevel = 'confirmed', marketName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.signTransaction({
                transaction,
                payer,
                signers: additionalSigners,
            });
            const rawTransaction = transaction.serialize();
            const startTime = (0, exports.getUnixTs)();
            const txid = yield this.connection.sendRawTransaction(rawTransaction, { skipPreflight: true });
            if (this.postSendTxCallback) {
                try {
                    this.postSendTxCallback({ txid });
                }
                catch (e) {
                    console.log(new Date().toISOString(), `${marketName} postSendTxCallback error ${e}`);
                }
            }
            // console.log('checking timeout');
            timeout = this.timeout || timeout;
            if (!timeout)
                return txid;
            console.log(new Date().toISOString(), `${marketName} Started awaiting confirmation for txid: `, txid, ' size:', rawTransaction.length);
            let done = false;
            let retryCount = 0;
            let retrySleep = 1000;
            (() => __awaiter(this, void 0, void 0, function* () {
                // TODO - make sure this works well on mainnet
                while (!done && (0, exports.getUnixTs)() - startTime < timeout / 1000) {
                    retryCount += 1;
                    yield (0, utils_1.sleep)(retrySleep);
                    // console.log(new Date().toISOString(), `retry number: `, retryCount, `Retrying tx `, txid, );
                    this.connection.sendRawTransaction(rawTransaction, {
                        skipPreflight: true,
                    });
                }
                if (retrySleep <= 8000) {
                    retrySleep = retrySleep * 2;
                }
            }))();
            try {
                yield this.awaitTransactionSignatureConfirmation(txid, timeout, confirmLevel);
            }
            catch (err) {
                if (err.timeout) {
                    throw new _1.TimeoutError({ txid });
                }
                let simulateResult = null;
                try {
                    simulateResult = (yield (0, utils_1.simulateTransaction)(this.connection, transaction, 'confirmed')).value;
                }
                catch (e) {
                    console.warn('Simulate transaction failed');
                }
                if (simulateResult && simulateResult.err) {
                    if (simulateResult.logs) {
                        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {
                            const line = simulateResult.logs[i];
                            if (line.startsWith('Program log: ')) {
                                throw new _1.EntropyError({
                                    message: new Date().toISOString() + `Transaction failed: ` + line.slice('Program log: '.length),
                                    txid,
                                });
                            }
                        }
                    }
                    throw new _1.EntropyError({
                        message: JSON.stringify(simulateResult.err),
                        txid,
                    });
                }
                throw new _1.EntropyError({
                    message: new Date().toISOString() + ' Transaction failed', txid
                });
            }
            finally {
                done = true;
            }
            console.log(new Date().toISOString(), `Transaction Latency for txid: `, txid, (0, exports.getUnixTs)() - startTime);
            return txid;
        });
    }
    sendSignedTransaction({ signedTransaction, timeout = 60000, confirmLevel = 'confirmed', }) {
        return __awaiter(this, void 0, void 0, function* () {
            const rawTransaction = signedTransaction.serialize();
            const startTime = (0, exports.getUnixTs)();
            const txid = yield this.connection.sendRawTransaction(rawTransaction, {
                skipPreflight: true,
            });
            if (this.postSendTxCallback) {
                try {
                    this.postSendTxCallback({ txid });
                }
                catch (e) {
                    console.log(new Date().toISOString(), `postSendTxCallback error ${e}`);
                }
            }
            // console.log('Started awaiting confirmation for', txid);
            let done = false;
            (() => __awaiter(this, void 0, void 0, function* () {
                yield (0, utils_1.sleep)(500);
                while (!done && (0, exports.getUnixTs)() - startTime < timeout) {
                    this.connection.sendRawTransaction(rawTransaction, {
                        skipPreflight: true,
                    });
                    yield (0, utils_1.sleep)(1000);
                }
            }))();
            try {
                yield this.awaitTransactionSignatureConfirmation(txid, timeout, confirmLevel);
            }
            catch (err) {
                if (err.timeout) {
                    throw new _1.TimeoutError({ txid });
                }
                let simulateResult = null;
                try {
                    simulateResult = (yield (0, utils_1.simulateTransaction)(this.connection, signedTransaction, 'confirmed')).value;
                }
                catch (e) {
                    console.log(new Date().toISOString(), 'Simulate tx failed');
                }
                if (simulateResult && simulateResult.err) {
                    if (simulateResult.logs) {
                        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {
                            const line = simulateResult.logs[i];
                            if (line.startsWith('Program log: ')) {
                                throw new _1.EntropyError({
                                    message: 'Transaction failed: ' + line.slice('Program log: '.length),
                                    txid,
                                });
                            }
                        }
                    }
                    throw new _1.EntropyError({
                        message: JSON.stringify(simulateResult.err),
                        txid,
                    });
                }
                throw new _1.EntropyError({ message: 'Transaction failed', txid });
            }
            finally {
                done = true;
            }
            console.log(new Date().toISOString(), 'Transaction Latency for txid: ', txid, (0, exports.getUnixTs)() - startTime);
            return txid;
        });
    }
    awaitTransactionSignatureConfirmation(txid, timeout, confirmLevel) {
        return __awaiter(this, void 0, void 0, function* () {
            let done = false;
            const confirmLevels = ['finalized'];
            if (confirmLevel === 'confirmed') {
                confirmLevels.push('confirmed');
            }
            else if (confirmLevel === 'processed') {
                confirmLevels.push('confirmed');
                confirmLevels.push('processed');
            }
            let subscriptionId;
            const result = yield new Promise((resolve, reject) => {
                (() => __awaiter(this, void 0, void 0, function* () {
                    setTimeout(() => {
                        if (done) {
                            return;
                        }
                        done = true;
                        console.log(new Date().toISOString(), 'Timed out for txid: ', txid);
                        reject({ timeout: true });
                    }, timeout);
                    try {
                        subscriptionId = this.connection.onSignature(txid, (result, context) => {
                            subscriptionId = undefined;
                            done = true;
                            if (result.err) {
                                reject(result.err);
                            }
                            else {
                                this.lastSlot = context === null || context === void 0 ? void 0 : context.slot;
                                resolve(result);
                            }
                        }, 'confirmed');
                    }
                    catch (e) {
                        done = true;
                        console.log(new Date().toISOString(), 'WS error in setup', txid, e);
                    }
                    let retrySleep = 400;
                    while (!done) {
                        // eslint-disable-next-line no-loop-func
                        yield (0, utils_1.sleep)(retrySleep);
                        (() => __awaiter(this, void 0, void 0, function* () {
                            var _a;
                            try {
                                const response = yield this.connection.getSignatureStatuses([
                                    txid,
                                ]);
                                const result = response && response.value[0];
                                if (!done) {
                                    if (!result) {
                                        // console.log('REST null result for', txid, result);
                                    }
                                    else if (result.err) {
                                        console.log(new Date().toISOString(), 'REST error for', txid, result);
                                        done = true;
                                        reject(result.err);
                                    }
                                    else if (!(result.confirmations ||
                                        confirmLevels.includes(result.confirmationStatus))) {
                                        console.log(new Date().toISOString(), 'REST not confirmed', txid, result);
                                    }
                                    else {
                                        this.lastSlot = (_a = response === null || response === void 0 ? void 0 : response.context) === null || _a === void 0 ? void 0 : _a.slot;
                                        // console.log('REST confirmed', txid, result);
                                        done = true;
                                        resolve(result);
                                    }
                                }
                            }
                            catch (e) {
                                if (!done) {
                                    console.log(new Date().toISOString(), 'REST connection error: txid', txid, e);
                                }
                            }
                        }))();
                        if (retrySleep <= 1600) {
                            retrySleep = retrySleep * 2;
                        }
                    }
                }))();
            });
            if (subscriptionId) {
                this.connection.removeSignatureListener(subscriptionId).catch((e) => {
                    console.log(new Date().toISOString(), 'WS error in cleanup', e);
                });
            }
            done = true;
            return result;
        });
    }
    updateRecentBlockhash(blockhashTimes) {
        return __awaiter(this, void 0, void 0, function* () {
            const now = (0, exports.getUnixTs)();
            const blockhash = (yield this.connection.getRecentBlockhash('confirmed')).blockhash;
            blockhashTimes.push({ blockhash, timestamp: now });
            const blockhashTime = (blockhashTimes.length >= this.maxStoredBlockhashes
                ? blockhashTimes.shift()
                : blockhashTimes[0]);
            this.timeout = 90000 - (now - blockhashTime.timestamp);
            this.recentBlockhash = blockhashTime.blockhash;
            this.recentBlockhashTime = blockhashTime.timestamp;
        });
    }
    /**
     * Maintain a timeout of 30 seconds
     * @param client
     */
    maintainTimeouts() {
        return __awaiter(this, void 0, void 0, function* () {
            const blockhashTimes = [];
            // eslint-disable-next-line no-constant-condition
            while (true) {
                yield this.updateRecentBlockhash(blockhashTimes);
                yield (0, utils_1.sleep)(10);
            }
        });
    }
    /**
     * Create a new Entropy group
     */
    initEntropyGroup(quoteMint, msrmMint, dexProgram, feesVault, // owned by Entropy DAO token governance
        validInterval, quoteOptimalUtil, quoteOptimalRate, quoteMaxRate, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            const accountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, payer.publicKey, layout_1.EntropyGroupLayout.span, this.programId);
            const { signerKey, signerNonce } = yield (0, utils_1.createSignerKeyAndNonce)(this.programId, accountInstruction.account.publicKey);
            const quoteVaultAccount = new web3_js_1.Account();
            const quoteVaultAccountInstructions = yield (0, utils_1.createTokenAccountInstructions)(this.connection, payer.publicKey, quoteVaultAccount.publicKey, quoteMint, signerKey);
            const insuranceVaultAccount = new web3_js_1.Account();
            const insuranceVaultAccountInstructions = yield (0, utils_1.createTokenAccountInstructions)(this.connection, payer.publicKey, insuranceVaultAccount.publicKey, quoteMint, signerKey);
            const quoteNodeBankAccountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, payer.publicKey, layout_1.NodeBankLayout.span, this.programId);
            const quoteRootBankAccountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, payer.publicKey, layout_1.RootBankLayout.span, this.programId);
            const cacheAccountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, payer.publicKey, layout_1.EntropyCacheLayout.span, this.programId);
            const createAccountsTransaction = new web3_js_1.Transaction();
            createAccountsTransaction.add(accountInstruction.instruction);
            createAccountsTransaction.add(...quoteVaultAccountInstructions);
            createAccountsTransaction.add(quoteNodeBankAccountInstruction.instruction);
            createAccountsTransaction.add(quoteRootBankAccountInstruction.instruction);
            createAccountsTransaction.add(cacheAccountInstruction.instruction);
            createAccountsTransaction.add(...insuranceVaultAccountInstructions);
            const signers = [
                accountInstruction.account,
                quoteVaultAccount,
                quoteNodeBankAccountInstruction.account,
                quoteRootBankAccountInstruction.account,
                cacheAccountInstruction.account,
                insuranceVaultAccount,
            ];
            yield this.sendTransaction(createAccountsTransaction, payer, signers);
            // If valid msrmMint passed in, then create new msrmVault
            let msrmVaultPk;
            if (!msrmMint.equals(utils_1.zeroKey)) {
                const msrmVaultAccount = new web3_js_1.Account();
                const msrmVaultAccountInstructions = yield (0, utils_1.createTokenAccountInstructions)(this.connection, payer.publicKey, msrmVaultAccount.publicKey, msrmMint, signerKey);
                const createMsrmVaultTransaction = new web3_js_1.Transaction();
                createMsrmVaultTransaction.add(...msrmVaultAccountInstructions);
                msrmVaultPk = msrmVaultAccount.publicKey;
                yield this.sendTransaction(createMsrmVaultTransaction, payer, [
                    msrmVaultAccount,
                ]);
            }
            else {
                msrmVaultPk = utils_1.zeroKey;
            }
            const initEntropyGroupInstruction = (0, instruction_1.makeInitEntropyGroupInstruction)(this.programId, accountInstruction.account.publicKey, signerKey, payer.publicKey, quoteMint, quoteVaultAccount.publicKey, quoteNodeBankAccountInstruction.account.publicKey, quoteRootBankAccountInstruction.account.publicKey, insuranceVaultAccount.publicKey, msrmVaultPk, feesVault, cacheAccountInstruction.account.publicKey, dexProgram, new bn_js_1.default(signerNonce), new bn_js_1.default(validInterval), fixednum_1.I80F48.fromNumber(quoteOptimalUtil), fixednum_1.I80F48.fromNumber(quoteOptimalRate), fixednum_1.I80F48.fromNumber(quoteMaxRate));
            const initEntropyGroupTransaction = new web3_js_1.Transaction();
            initEntropyGroupTransaction.add(initEntropyGroupInstruction);
            yield this.sendTransaction(initEntropyGroupTransaction, payer, []);
            return accountInstruction.account.publicKey;
        });
    }
    /**
     * Retrieve information about a Entropy Group
     */
    getEntropyGroup(entropyGroup) {
        return __awaiter(this, void 0, void 0, function* () {
            const accountInfo = yield this.connection.getAccountInfo(entropyGroup);
            const decoded = layout_1.EntropyGroupLayout.decode(accountInfo == null ? undefined : accountInfo.data);
            return new EntropyGroup_1.default(entropyGroup, decoded);
        });
    }
    /**
     * Create a new Entropy Account on a given group
     */
    initEntropyAccount(entropyGroup, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const accountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, owner.publicKey, layout_1.EntropyAccountLayout.span, this.programId);
            const initEntropyAccountInstruction = (0, instruction_1.makeInitEntropyAccountInstruction)(this.programId, entropyGroup.publicKey, accountInstruction.account.publicKey, owner.publicKey);
            // Add all instructions to one atomic transaction
            const transaction = new web3_js_1.Transaction();
            transaction.add(accountInstruction.instruction);
            transaction.add(initEntropyAccountInstruction);
            const additionalSigners = [accountInstruction.account];
            yield this.sendTransaction(transaction, owner, additionalSigners);
            return accountInstruction.account.publicKey;
        });
    }
    /**
     * Retrieve information about a Entropy Account
     */
    getEntropyAccount(entropyAccountPk, dexProgramId) {
        return __awaiter(this, void 0, void 0, function* () {
            const acc = yield this.connection.getAccountInfo(entropyAccountPk, 'confirmed');
            const entropyAccount = new EntropyAccount_1.default(entropyAccountPk, layout_1.EntropyAccountLayout.decode(acc == null ? undefined : acc.data));
            yield entropyAccount.loadOpenOrders(this.connection, dexProgramId);
            return entropyAccount;
        });
    }
    /**
     * Create a new Entropy Account and deposit some tokens in a single transaction
     *
     * @param rootBank The RootBank for the deposit currency
     * @param nodeBank The NodeBank asociated with the RootBank
     * @param vault The token account asociated with the NodeBank
     * @param tokenAcc The token account to transfer from
     * @param info An optional UI name for the account
     */
    initEntropyAccountAndDeposit(entropyGroup, owner, rootBank, nodeBank, vault, tokenAcc, quantity, info) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = new web3_js_1.Transaction();
            const accountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, owner.publicKey, layout_1.EntropyAccountLayout.span, this.programId);
            const initEntropyAccountInstruction = (0, instruction_1.makeInitEntropyAccountInstruction)(this.programId, entropyGroup.publicKey, accountInstruction.account.publicKey, owner.publicKey);
            transaction.add(accountInstruction.instruction);
            transaction.add(initEntropyAccountInstruction);
            const additionalSigners = [accountInstruction.account];
            const tokenIndex = entropyGroup.getRootBankIndex(rootBank);
            const tokenMint = entropyGroup.tokens[tokenIndex].mint;
            let wrappedSolAccount = null;
            if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT) &&
                tokenAcc.toBase58() === owner.publicKey.toBase58()) {
                wrappedSolAccount = new web3_js_1.Account();
                const lamports = Math.round(quantity * web3_js_1.LAMPORTS_PER_SOL) + 1e7;
                transaction.add(web3_js_1.SystemProgram.createAccount({
                    fromPubkey: owner.publicKey,
                    newAccountPubkey: wrappedSolAccount.publicKey,
                    lamports,
                    space: 165,
                    programId: spl_token_1.TOKEN_PROGRAM_ID,
                }));
                transaction.add((0, token_instructions_1.initializeAccount)({
                    account: wrappedSolAccount.publicKey,
                    mint: token_instructions_1.WRAPPED_SOL_MINT,
                    owner: owner.publicKey,
                }));
                additionalSigners.push(wrappedSolAccount);
            }
            const nativeQuantity = (0, utils_1.uiToNative)(quantity, entropyGroup.tokens[tokenIndex].decimals);
            const instruction = (0, instruction_1.makeDepositInstruction)(this.programId, entropyGroup.publicKey, owner.publicKey, entropyGroup.entropyCache, accountInstruction.account.publicKey, rootBank, nodeBank, vault, (_a = wrappedSolAccount === null || wrappedSolAccount === void 0 ? void 0 : wrappedSolAccount.publicKey) !== null && _a !== void 0 ? _a : tokenAcc, nativeQuantity);
            transaction.add(instruction);
            if (info) {
                const addAccountNameinstruction = (0, instruction_1.makeAddEntropyAccountInfoInstruction)(this.programId, entropyGroup.publicKey, accountInstruction.account.publicKey, owner.publicKey, info);
                transaction.add(addAccountNameinstruction);
            }
            if (wrappedSolAccount) {
                transaction.add((0, token_instructions_1.closeAccount)({
                    source: wrappedSolAccount.publicKey,
                    destination: owner.publicKey,
                    owner: owner.publicKey,
                }));
            }
            yield this.sendTransaction(transaction, owner, additionalSigners);
            return accountInstruction.account.publicKey.toString();
        });
    }
    /**
     * Deposit tokens in a Entropy Account
     *
     * @param rootBank The RootBank for the deposit currency
     * @param nodeBank The NodeBank asociated with the RootBank
     * @param vault The token account asociated with the NodeBank
     * @param tokenAcc The token account to transfer from
     */
    deposit(entropyGroup, entropyAccount, owner, rootBank, nodeBank, vault, tokenAcc, quantity) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = new web3_js_1.Transaction();
            const additionalSigners = [];
            const tokenIndex = entropyGroup.getRootBankIndex(rootBank);
            const tokenMint = entropyGroup.tokens[tokenIndex].mint;
            let wrappedSolAccount = null;
            if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT) &&
                tokenAcc.toBase58() === owner.publicKey.toBase58()) {
                wrappedSolAccount = new web3_js_1.Account();
                const lamports = Math.round(quantity * web3_js_1.LAMPORTS_PER_SOL) + 1e7;
                transaction.add(web3_js_1.SystemProgram.createAccount({
                    fromPubkey: owner.publicKey,
                    newAccountPubkey: wrappedSolAccount.publicKey,
                    lamports,
                    space: 165,
                    programId: spl_token_1.TOKEN_PROGRAM_ID,
                }));
                transaction.add((0, token_instructions_1.initializeAccount)({
                    account: wrappedSolAccount.publicKey,
                    mint: token_instructions_1.WRAPPED_SOL_MINT,
                    owner: owner.publicKey,
                }));
                additionalSigners.push(wrappedSolAccount);
            }
            const nativeQuantity = (0, utils_1.uiToNative)(quantity, entropyGroup.tokens[tokenIndex].decimals);
            const instruction = (0, instruction_1.makeDepositInstruction)(this.programId, entropyGroup.publicKey, owner.publicKey, entropyGroup.entropyCache, entropyAccount.publicKey, rootBank, nodeBank, vault, (_a = wrappedSolAccount === null || wrappedSolAccount === void 0 ? void 0 : wrappedSolAccount.publicKey) !== null && _a !== void 0 ? _a : tokenAcc, nativeQuantity);
            transaction.add(instruction);
            if (wrappedSolAccount) {
                transaction.add((0, token_instructions_1.closeAccount)({
                    source: wrappedSolAccount.publicKey,
                    destination: owner.publicKey,
                    owner: owner.publicKey,
                }));
            }
            return yield this.sendTransaction(transaction, owner, additionalSigners);
        });
    }
    /**
     * Deposit tokens in a Entropy Account
     *
     * @param rootBank The RootBank for the withdrawn currency
     * @param nodeBank The NodeBank asociated with the RootBank
     * @param vault The token account asociated with the NodeBank
     * @param allowBorrow Whether to borrow tokens if there are not enough deposits for the withdrawal
     */
    withdraw(entropyGroup, entropyAccount, owner, rootBank, nodeBank, vault, quantity, allowBorrow) {
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = new web3_js_1.Transaction();
            const additionalSigners = [];
            const tokenIndex = entropyGroup.getRootBankIndex(rootBank);
            const tokenMint = entropyGroup.tokens[tokenIndex].mint;
            let tokenAcc = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, owner.publicKey);
            let wrappedSolAccount = null;
            if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT)) {
                wrappedSolAccount = new web3_js_1.Account();
                tokenAcc = wrappedSolAccount.publicKey;
                const space = 165;
                const lamports = yield this.connection.getMinimumBalanceForRentExemption(space, 'confirmed');
                transaction.add(web3_js_1.SystemProgram.createAccount({
                    fromPubkey: owner.publicKey,
                    newAccountPubkey: tokenAcc,
                    lamports,
                    space,
                    programId: spl_token_1.TOKEN_PROGRAM_ID,
                }));
                transaction.add((0, token_instructions_1.initializeAccount)({
                    account: tokenAcc,
                    mint: token_instructions_1.WRAPPED_SOL_MINT,
                    owner: owner.publicKey,
                }));
                additionalSigners.push(wrappedSolAccount);
            }
            else {
                const tokenAccExists = yield this.connection.getAccountInfo(tokenAcc, 'recent');
                if (!tokenAccExists) {
                    transaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, tokenAcc, owner.publicKey, owner.publicKey));
                }
            }
            const nativeQuantity = (0, utils_1.uiToNative)(quantity, entropyGroup.tokens[tokenIndex].decimals);
            const instruction = (0, instruction_1.makeWithdrawInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, entropyGroup.entropyCache, rootBank, nodeBank, vault, tokenAcc, entropyGroup.signerKey, entropyAccount.spotOpenOrders, nativeQuantity, allowBorrow);
            transaction.add(instruction);
            if (wrappedSolAccount) {
                transaction.add((0, token_instructions_1.closeAccount)({
                    source: wrappedSolAccount.publicKey,
                    destination: owner.publicKey,
                    owner: owner.publicKey,
                }));
            }
            return yield this.sendTransaction(transaction, owner, additionalSigners);
        });
    }
    changeMaxAccounts(entropyGroupPk, admin, numAccounts) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('num accounts = ', numAccounts.toString());
            const instruction = (0, instruction_2.makeChangeMaxEntropyAccountsInstruction)(this.programId, entropyGroupPk, admin.publicKey, numAccounts);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, admin, additionalSigners);
        });
    }
    /**
     * Called by the Keeper to cache interest rates from the RootBanks
     */
    cacheRootBanks(entropyGroup, entropyCache, rootBanks, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            const cacheRootBanksInstruction = (0, instruction_1.makeCacheRootBankInstruction)(this.programId, entropyGroup, entropyCache, rootBanks);
            const transaction = new web3_js_1.Transaction();
            transaction.add(cacheRootBanksInstruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    /**
     * Called by the Keeper to cache prices from the Oracles
     */
    cachePrices(entropyGroup, entropyCache, oracles, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            const cachePricesInstruction = (0, instruction_1.makeCachePricesInstruction)(this.programId, entropyGroup, entropyCache, oracles);
            const transaction = new web3_js_1.Transaction();
            transaction.add(cachePricesInstruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    /**
     * Called by the Keeper to cache perp market funding
     */
    cachePerpMarkets(entropyGroup, entropyCache, perpMarkets, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            const cachePerpMarketsInstruction = (0, instruction_1.makeCachePerpMarketsInstruction)(this.programId, entropyGroup, entropyCache, perpMarkets);
            const transaction = new web3_js_1.Transaction();
            transaction.add(cachePerpMarketsInstruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    /**
     * Called by the Keeper to update interest rates on the RootBanks
     */
    updateRootBank(entropyGroup, rootBank, nodeBanks, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            const updateRootBanksInstruction = (0, instruction_1.makeUpdateRootBankInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, rootBank, nodeBanks);
            const transaction = new web3_js_1.Transaction();
            transaction.add(updateRootBanksInstruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    /**
     * Called by the Keeper to process events on the Perp order book
     */
    consumeEvents(entropyGroup, perpMarket, entropyAccounts, payer, limit) {
        return __awaiter(this, void 0, void 0, function* () {
            const consumeEventsInstruction = (0, instruction_1.makeConsumeEventsInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, perpMarket.publicKey, perpMarket.eventQueue, entropyAccounts, limit);
            const transaction = new web3_js_1.Transaction();
            transaction.add(consumeEventsInstruction);
            return yield this.sendTransaction(transaction, payer, [], null);
        });
    }
    /**
     * Called by the Keeper to update funding on the perp markets
     */
    updateFunding(entropyGroup, entropyCache, perpMarket, bids, asks, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            const updateFundingInstruction = (0, instruction_1.makeUpdateFundingInstruction)(this.programId, entropyGroup, entropyCache, perpMarket, bids, asks);
            const transaction = new web3_js_1.Transaction();
            transaction.add(updateFundingInstruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    /**
     * Retrieve information about a perp market
     */
    getPerpMarket(perpMarketPk, baseDecimal, quoteDecimal) {
        return __awaiter(this, void 0, void 0, function* () {
            const acc = yield this.connection.getAccountInfo(perpMarketPk);
            const perpMarket = new PerpMarket_1.default(perpMarketPk, baseDecimal, quoteDecimal, layout_1.PerpMarketLayout.decode(acc === null || acc === void 0 ? void 0 : acc.data));
            return perpMarket;
        });
    }
    /**
     * Place an order on a perp market
     *
     * @param clientOrderId An optional id that can be used to correlate events related to your order
     * @param bookSideInfo Account info for asks if side === bid, bids if side === ask. If this is given, crank instruction is added
     */
    placePerpOrder(entropyGroup, entropyAccount, entropyCache, // TODO - remove; already in EntropyGroup
        perpMarket, owner, side, price, quantity, orderType, clientOrderId = 0, bookSideInfo, reduceOnly) {
        return __awaiter(this, void 0, void 0, function* () {
            const [nativePrice, nativeQuantity] = perpMarket.uiToNativePriceQuantity(price, quantity);
            const transaction = new web3_js_1.Transaction();
            const additionalSigners = [];
            const instruction = (0, instruction_1.makePlacePerpOrderInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, entropyCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, perpMarket.eventQueue, entropyAccount.spotOpenOrders, nativePrice, nativeQuantity, new bn_js_1.default(clientOrderId), side, orderType, reduceOnly);
            transaction.add(instruction);
            if (bookSideInfo) {
                const bookSide = bookSideInfo.data
                    ? new book_1.BookSide(side === 'buy' ? perpMarket.asks : perpMarket.bids, perpMarket, layout_1.BookSideLayout.decode(bookSideInfo.data))
                    : [];
                const accounts = new Set();
                accounts.add(entropyAccount.publicKey.toBase58());
                for (const order of bookSide) {
                    accounts.add(order.owner.toBase58());
                    if (accounts.size >= 10) {
                        break;
                    }
                }
                const consumeInstruction = (0, instruction_1.makeConsumeEventsInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, perpMarket.publicKey, perpMarket.eventQueue, Array.from(accounts)
                    .map((s) => new web3_js_1.PublicKey(s))
                    .sort(), new bn_js_1.default(4));
                transaction.add(consumeInstruction);
            }
            return yield this.sendTransaction(transaction, owner, additionalSigners);
        });
    }
    /**
     * Cancel an order on a perp market
     *
     * @param invalidIdOk Don't throw error if order is invalid
     */
    cancelPerpOrder(entropyGroup, entropyAccount, owner, perpMarket, order, invalidIdOk = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeCancelPerpOrderInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, order, invalidIdOk);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, owner, additionalSigners);
        });
    }
    /**
     * Cancel all perp orders across all markets
     */
    cancelAllPerpOrders(group, perpMarkets, entropyAccount, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            let tx = new web3_js_1.Transaction();
            const transactions = [];
            // Determine which market indexes have open orders
            const hasOrders = new Array(group.perpMarkets.length).fill(false);
            for (let i = 0; i < entropyAccount.orderMarket.length; i++) {
                if (entropyAccount.orderMarket[i] !== layout_1.FREE_ORDER_SLOT) {
                    hasOrders[entropyAccount.orderMarket[i]] = true;
                }
            }
            for (let i = 0; i < group.perpMarkets.length; i++) {
                if (!hasOrders[i])
                    continue;
                const pmi = group.perpMarkets[i];
                if (pmi.isEmpty())
                    continue;
                const perpMarket = perpMarkets.find((pm) => pm.publicKey.equals(pmi.perpMarket));
                if (perpMarket === undefined)
                    continue;
                const cancelAllInstr = (0, instruction_1.makeCancelAllPerpOrdersInstruction)(this.programId, group.publicKey, entropyAccount.publicKey, owner.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, new bn_js_1.default(20));
                tx.add(cancelAllInstr);
                if (tx.instructions.length === 2) {
                    transactions.push(tx);
                    tx = new web3_js_1.Transaction();
                }
            }
            if (tx.instructions.length > 0) {
                transactions.push(tx);
            }
            const transactionsAndSigners = transactions.map((tx) => ({
                transaction: tx,
                signers: [],
            }));
            if (transactionsAndSigners.length === 0) {
                throw new Error('No orders to cancel');
            }
            // Sign multiple transactions at once for better UX
            const signedTransactions = yield this.signTransactions({
                transactionsAndSigners,
                payer: owner,
            });
            if (signedTransactions) {
                return yield Promise.all(signedTransactions.map((signedTransaction) => this.sendSignedTransaction({ signedTransaction })));
            }
            else {
                throw new Error('Unable to sign all CancelAllPerpOrders transactions');
            }
        });
    }
    /*
    async loadPerpMarkets(perpMarkets: PublicKey[]): Promise<PerpMarket[]> {
      const accounts = await Promise.all(
        perpMarkets.map((pk) => this.connection.getAccountInfo(pk)),
      );
  
      const parsedPerpMarkets: PerpMarket[] = [];
  
      for (let i = 0; i < accounts.length; i++) {
        const acc = accounts[i];
        if (acc) {
          const decoded = PerpMarketLayout.decode(acc.data);
          parsedPerpMarkets.push(new PerpMarket(perpMarkets[i], decoded));
        }
      }
  
      return parsedPerpMarkets;
    }
    */
    /**
     * Add a new oracle to a group
     */
    addOracle(entropyGroup, oracle, admin) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeAddOracleInstruction)(this.programId, entropyGroup.publicKey, oracle, admin.publicKey);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, admin, additionalSigners);
        });
    }
    /**
     * Set the price of a 'stub' type oracle
     */
    setOracle(entropyGroup, oracle, admin, price) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeSetOracleInstruction)(this.programId, entropyGroup.publicKey, oracle, admin.publicKey, price);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, admin, additionalSigners);
        });
    }
    addSpotMarket(entropyGroup, oracle, spotMarket, mint, admin, maintLeverage, initLeverage, liquidationFee, optimalUtil, optimalRate, maxRate) {
        return __awaiter(this, void 0, void 0, function* () {
            const vaultAccount = new web3_js_1.Account();
            const vaultAccountInstructions = yield (0, utils_1.createTokenAccountInstructions)(this.connection, admin.publicKey, vaultAccount.publicKey, mint, entropyGroup.signerKey);
            const nodeBankAccountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, admin.publicKey, layout_1.NodeBankLayout.span, this.programId);
            const rootBankAccountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, admin.publicKey, layout_1.RootBankLayout.span, this.programId);
            const instruction = (0, instruction_1.makeAddSpotMarketInstruction)(this.programId, entropyGroup.publicKey, oracle, spotMarket, entropyGroup.dexProgramId, mint, nodeBankAccountInstruction.account.publicKey, vaultAccount.publicKey, rootBankAccountInstruction.account.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumber(maintLeverage), fixednum_1.I80F48.fromNumber(initLeverage), fixednum_1.I80F48.fromNumber(liquidationFee), fixednum_1.I80F48.fromNumber(optimalUtil), fixednum_1.I80F48.fromNumber(optimalRate), fixednum_1.I80F48.fromNumber(maxRate));
            const transaction = new web3_js_1.Transaction();
            transaction.add(...vaultAccountInstructions);
            transaction.add(nodeBankAccountInstruction.instruction);
            transaction.add(rootBankAccountInstruction.instruction);
            transaction.add(instruction);
            const additionalSigners = [
                vaultAccount,
                nodeBankAccountInstruction.account,
                rootBankAccountInstruction.account,
            ];
            return yield this.sendTransaction(transaction, admin, additionalSigners);
        });
    }
    /**
     * Make sure entropyAccount has recent and valid inMarginBasket and spotOpenOrders
     */
    placeSpotOrder(entropyGroup, entropyAccount, entropyCache, spotMarket, owner, side, price, size, orderType, clientId) {
        return __awaiter(this, void 0, void 0, function* () {
            const limitPrice = spotMarket.priceNumberToLots(price);
            const maxBaseQuantity = spotMarket.baseSizeNumberToLots(size);
            // TODO implement srm vault fee discount
            // const feeTier = getFeeTier(0, nativeToUi(entropyGroup.nativeSrm || 0, SRM_DECIMALS));
            const feeTier = (0, serum_1.getFeeTier)(0, (0, utils_1.nativeToUi)(0, 0));
            const rates = (0, serum_1.getFeeRates)(feeTier);
            const maxQuoteQuantity = new bn_js_1.default(spotMarket['_decoded'].quoteLotSize.toNumber() * (1 + rates.taker)).mul(spotMarket
                .baseSizeNumberToLots(size)
                .mul(spotMarket.priceNumberToLots(price)));
            if (maxBaseQuantity.lte(utils_1.ZERO_BN)) {
                throw new Error('size too small');
            }
            if (limitPrice.lte(utils_1.ZERO_BN)) {
                throw new Error('invalid price');
            }
            const selfTradeBehavior = 'decrementTake';
            clientId = clientId !== null && clientId !== void 0 ? clientId : new bn_js_1.default(Date.now());
            const spotMarketIndex = entropyGroup.getSpotMarketIndex(spotMarket.publicKey);
            if (!entropyGroup.rootBankAccounts.filter((a) => !!a).length) {
                yield entropyGroup.loadRootBanks(this.connection);
            }
            const baseRootBank = entropyGroup.rootBankAccounts[spotMarketIndex];
            const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];
            const quoteRootBank = entropyGroup.rootBankAccounts[layout_1.QUOTE_INDEX];
            const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];
            if (!baseRootBank || !baseNodeBank || !quoteRootBank || !quoteNodeBank) {
                throw new Error('Invalid or missing banks');
            }
            const transaction = new web3_js_1.Transaction();
            const additionalSigners = [];
            const openOrdersKeys = [];
            // Only pass in open orders if in margin basket or current market index, and
            // the only writable account should be OpenOrders for current market index
            for (let i = 0; i < entropyAccount.spotOpenOrders.length; i++) {
                let pubkey = utils_1.zeroKey;
                let isWritable = false;
                if (i === spotMarketIndex) {
                    isWritable = true;
                    if (entropyAccount.spotOpenOrders[spotMarketIndex].equals(utils_1.zeroKey)) {
                        // open orders missing for this market; create a new one now
                        const openOrdersSpace = serum_1.OpenOrders.getLayout(entropyGroup.dexProgramId).span;
                        const openOrdersLamports = yield this.connection.getMinimumBalanceForRentExemption(openOrdersSpace, 'confirmed');
                        const accInstr = yield (0, utils_1.createAccountInstruction)(this.connection, owner.publicKey, openOrdersSpace, entropyGroup.dexProgramId, openOrdersLamports);
                        const initOpenOrders = (0, instruction_1.makeInitSpotOpenOrdersInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, entropyGroup.dexProgramId, accInstr.account.publicKey, spotMarket.publicKey, entropyGroup.signerKey);
                        const initTx = new web3_js_1.Transaction();
                        initTx.add(accInstr.instruction);
                        initTx.add(initOpenOrders);
                        yield this.sendTransaction(initTx, owner, [accInstr.account]);
                        pubkey = accInstr.account.publicKey;
                    }
                    else {
                        pubkey = entropyAccount.spotOpenOrders[i];
                    }
                }
                else if (entropyAccount.inMarginBasket[i]) {
                    pubkey = entropyAccount.spotOpenOrders[i];
                }
                openOrdersKeys.push({ pubkey, isWritable });
            }
            const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([
                spotMarket.publicKey.toBuffer(),
                spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),
            ], spotMarket.programId);
            const placeOrderInstruction = (0, instruction_1.makePlaceSpotOrderInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, entropyCache, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, spotMarket['_decoded'].requestQueue, spotMarket['_decoded'].eventQueue, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, baseRootBank.publicKey, baseNodeBank.publicKey, baseNodeBank.vault, quoteRootBank.publicKey, quoteNodeBank.publicKey, quoteNodeBank.vault, entropyGroup.signerKey, dexSigner, entropyGroup.srmVault, // TODO: choose msrm vault if it has any deposits
                openOrdersKeys, side, limitPrice, maxBaseQuantity, maxQuoteQuantity, selfTradeBehavior, orderType, clientId);
            transaction.add(placeOrderInstruction);
            if (spotMarketIndex > 0) {
                console.log(new Date().toISOString(), spotMarketIndex - 1, entropyAccount.spotOpenOrders[spotMarketIndex - 1].toBase58(), openOrdersKeys[spotMarketIndex - 1].pubkey.toBase58());
            }
            const txid = yield this.sendTransaction(transaction, owner, additionalSigners);
            // update EntropyAccount to have new OpenOrders pubkey
            entropyAccount.spotOpenOrders[spotMarketIndex] =
                openOrdersKeys[spotMarketIndex].pubkey;
            entropyAccount.inMarginBasket[spotMarketIndex] = true;
            console.log(new Date().toISOString(), spotMarketIndex, entropyAccount.spotOpenOrders[spotMarketIndex].toBase58(), openOrdersKeys[spotMarketIndex].pubkey.toBase58());
            return txid;
        });
    }
    /**
     * Make sure entropyAccount has recent and valid inMarginBasket and spotOpenOrders
     */
    placeSpotOrder2(entropyGroup, entropyAccount, spotMarket, owner, side, price, size, orderType, clientOrderId, useMsrmVault) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const limitPrice = spotMarket.priceNumberToLots(price);
            const maxBaseQuantity = spotMarket.baseSizeNumberToLots(size);
            // TODO implement srm vault fee discount
            // const feeTier = getFeeTier(0, nativeToUi(entropyGroup.nativeSrm || 0, SRM_DECIMALS));
            const feeTier = (0, serum_1.getFeeTier)(0, (0, utils_1.nativeToUi)(0, 0));
            const rates = (0, serum_1.getFeeRates)(feeTier);
            const maxQuoteQuantity = new bn_js_1.default(spotMarket['_decoded'].quoteLotSize.toNumber() * (1 + rates.taker)).mul(spotMarket
                .baseSizeNumberToLots(size)
                .mul(spotMarket.priceNumberToLots(price)));
            if (maxBaseQuantity.lte(utils_1.ZERO_BN)) {
                throw new Error('size too small');
            }
            if (limitPrice.lte(utils_1.ZERO_BN)) {
                throw new Error('invalid price');
            }
            const selfTradeBehavior = 'decrementTake';
            const spotMarketIndex = entropyGroup.getSpotMarketIndex(spotMarket.publicKey);
            if (!entropyGroup.rootBankAccounts.filter((a) => !!a).length) {
                yield entropyGroup.loadRootBanks(this.connection);
            }
            let feeVault = utils_1.zeroKey;
            if (useMsrmVault) {
                feeVault = entropyGroup.msrmVault;
            }
            else if (useMsrmVault === false) {
                feeVault = entropyGroup.srmVault;
            }
            else {
                const totalMsrm = yield this.connection.getTokenAccountBalance(entropyGroup.msrmVault);
                feeVault =
                    ((_a = totalMsrm === null || totalMsrm === void 0 ? void 0 : totalMsrm.value) === null || _a === void 0 ? void 0 : _a.uiAmount) && totalMsrm.value.uiAmount > 0
                        ? entropyGroup.msrmVault
                        : entropyGroup.srmVault;
            }
            const baseRootBank = entropyGroup.rootBankAccounts[spotMarketIndex];
            const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];
            const quoteRootBank = entropyGroup.rootBankAccounts[layout_1.QUOTE_INDEX];
            const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];
            if (!baseRootBank || !baseNodeBank || !quoteRootBank || !quoteNodeBank) {
                throw new Error('Invalid or missing banks');
            }
            const transaction = new web3_js_1.Transaction();
            const additionalSigners = [];
            const openOrdersKeys = [];
            // Only pass in open orders if in margin basket or current market index, and
            // the only writable account should be OpenOrders for current market index
            let marketOpenOrdersKey = utils_1.zeroKey;
            for (let i = 0; i < entropyAccount.spotOpenOrders.length; i++) {
                let pubkey = utils_1.zeroKey;
                let isWritable = false;
                if (i === spotMarketIndex) {
                    isWritable = true;
                    if (entropyAccount.spotOpenOrders[spotMarketIndex].equals(utils_1.zeroKey)) {
                        // open orders missing for this market; create a new one now
                        const openOrdersSpace = serum_1.OpenOrders.getLayout(entropyGroup.dexProgramId).span;
                        const openOrdersLamports = yield this.connection.getMinimumBalanceForRentExemption(openOrdersSpace, 'confirmed');
                        const accInstr = yield (0, utils_1.createAccountInstruction)(this.connection, owner.publicKey, openOrdersSpace, entropyGroup.dexProgramId, openOrdersLamports);
                        const initOpenOrders = (0, instruction_1.makeInitSpotOpenOrdersInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, entropyGroup.dexProgramId, accInstr.account.publicKey, spotMarket.publicKey, entropyGroup.signerKey);
                        const initTx = new web3_js_1.Transaction();
                        initTx.add(accInstr.instruction);
                        initTx.add(initOpenOrders);
                        yield this.sendTransaction(initTx, owner, [accInstr.account]);
                        pubkey = accInstr.account.publicKey;
                    }
                    else {
                        pubkey = entropyAccount.spotOpenOrders[i];
                    }
                    marketOpenOrdersKey = pubkey;
                }
                else if (entropyAccount.inMarginBasket[i]) {
                    pubkey = entropyAccount.spotOpenOrders[i];
                }
                // new design does not require zero keys to be passed in
                if (!pubkey.equals(utils_1.zeroKey)) {
                    openOrdersKeys.push({ pubkey, isWritable });
                }
            }
            const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([
                spotMarket.publicKey.toBuffer(),
                spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),
            ], spotMarket.programId);
            const placeOrderInstruction = (0, instruction_1.makePlaceSpotOrder2Instruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, entropyGroup.entropyCache, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, spotMarket['_decoded'].requestQueue, spotMarket['_decoded'].eventQueue, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, baseRootBank.publicKey, baseNodeBank.publicKey, baseNodeBank.vault, quoteRootBank.publicKey, quoteNodeBank.publicKey, quoteNodeBank.vault, entropyGroup.signerKey, dexSigner, feeVault, openOrdersKeys, side, limitPrice, maxBaseQuantity, maxQuoteQuantity, selfTradeBehavior, orderType, clientOrderId !== null && clientOrderId !== void 0 ? clientOrderId : new bn_js_1.default(Date.now()));
            transaction.add(placeOrderInstruction);
            const txid = yield this.sendTransaction(transaction, owner, additionalSigners);
            // update EntropyAccount to have new OpenOrders pubkey
            // We know this new key is in margin basket because if it was a full taker trade
            // there is some leftover from fee rebate. If maker trade there's the order.
            // and if it failed then we already exited before this line
            entropyAccount.spotOpenOrders[spotMarketIndex] = marketOpenOrdersKey;
            entropyAccount.inMarginBasket[spotMarketIndex] = true;
            console.log(new Date().toISOString(), spotMarketIndex, entropyAccount.spotOpenOrders[spotMarketIndex].toBase58(), marketOpenOrdersKey.toBase58());
            return txid;
        });
    }
    cancelSpotOrder(entropyGroup, entropyAccount, owner, spotMarket, order) {
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = new web3_js_1.Transaction();
            const instruction = (0, instruction_1.makeCancelSpotOrderInstruction)(this.programId, entropyGroup.publicKey, owner.publicKey, entropyAccount.publicKey, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, order.openOrdersAddress, entropyGroup.signerKey, spotMarket['_decoded'].eventQueue, order);
            transaction.add(instruction);
            const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([
                spotMarket.publicKey.toBuffer(),
                spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),
            ], spotMarket.programId);
            const marketIndex = entropyGroup.getSpotMarketIndex(spotMarket.publicKey);
            if (!entropyGroup.rootBankAccounts.length) {
                yield entropyGroup.loadRootBanks(this.connection);
            }
            const baseRootBank = entropyGroup.rootBankAccounts[marketIndex];
            const quoteRootBank = entropyGroup.rootBankAccounts[layout_1.QUOTE_INDEX];
            const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];
            const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];
            if (!baseNodeBank || !quoteNodeBank) {
                throw new Error('Invalid or missing node banks');
            }
            const settleFundsInstruction = (0, instruction_1.makeSettleFundsInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, owner.publicKey, entropyAccount.publicKey, spotMarket.programId, spotMarket.publicKey, entropyAccount.spotOpenOrders[marketIndex], entropyGroup.signerKey, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, entropyGroup.tokens[marketIndex].rootBank, baseNodeBank.publicKey, entropyGroup.tokens[layout_1.QUOTE_INDEX].rootBank, quoteNodeBank.publicKey, baseNodeBank.vault, quoteNodeBank.vault, dexSigner);
            transaction.add(settleFundsInstruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, owner, additionalSigners);
        });
    }
    settleFunds(entropyGroup, entropyAccount, owner, spotMarket) {
        return __awaiter(this, void 0, void 0, function* () {
            const marketIndex = entropyGroup.getSpotMarketIndex(spotMarket.publicKey);
            const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([
                spotMarket.publicKey.toBuffer(),
                spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),
            ], spotMarket.programId);
            if (!entropyGroup.rootBankAccounts.length) {
                yield entropyGroup.loadRootBanks(this.connection);
            }
            const baseRootBank = entropyGroup.rootBankAccounts[marketIndex];
            const quoteRootBank = entropyGroup.rootBankAccounts[layout_1.QUOTE_INDEX];
            const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];
            const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];
            if (!baseNodeBank || !quoteNodeBank) {
                throw new Error('Invalid or missing node banks');
            }
            const instruction = (0, instruction_1.makeSettleFundsInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, owner.publicKey, entropyAccount.publicKey, spotMarket.programId, spotMarket.publicKey, entropyAccount.spotOpenOrders[marketIndex], entropyGroup.signerKey, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, entropyGroup.tokens[marketIndex].rootBank, baseNodeBank.publicKey, entropyGroup.tokens[layout_1.QUOTE_INDEX].rootBank, quoteNodeBank.publicKey, baseNodeBank.vault, quoteNodeBank.vault, dexSigner);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, owner, additionalSigners);
        });
    }
    /**
     * Assumes spotMarkets contains all Markets in EntropyGroup in order
     */
    settleAll(entropyGroup, entropyAccount, spotMarkets, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const transactions = [];
            let j = 0;
            for (let i = 0; i < entropyGroup.spotMarkets.length; i++) {
                if (entropyGroup.spotMarkets[i].isEmpty())
                    continue;
                const spotMarket = spotMarkets[j];
                j++;
                const transaction = new web3_js_1.Transaction();
                const openOrdersAccount = entropyAccount.spotOpenOrdersAccounts[i];
                if (openOrdersAccount === undefined)
                    continue;
                if (openOrdersAccount.quoteTokenFree.toNumber() +
                    openOrdersAccount['referrerRebatesAccrued'].toNumber() ===
                    0 &&
                    openOrdersAccount.baseTokenFree.toNumber() === 0) {
                    continue;
                }
                const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([
                    spotMarket.publicKey.toBuffer(),
                    spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),
                ], spotMarket.programId);
                if (!entropyGroup.rootBankAccounts.length) {
                    yield entropyGroup.loadRootBanks(this.connection);
                }
                const baseRootBank = entropyGroup.rootBankAccounts[i];
                const quoteRootBank = entropyGroup.rootBankAccounts[layout_1.QUOTE_INDEX];
                const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];
                const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];
                if (!baseNodeBank || !quoteNodeBank) {
                    throw new Error('Invalid or missing node banks');
                }
                const instruction = (0, instruction_1.makeSettleFundsInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, owner.publicKey, entropyAccount.publicKey, spotMarket.programId, spotMarket.publicKey, entropyAccount.spotOpenOrders[i], entropyGroup.signerKey, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, entropyGroup.tokens[i].rootBank, baseNodeBank.publicKey, entropyGroup.tokens[layout_1.QUOTE_INDEX].rootBank, quoteNodeBank.publicKey, baseNodeBank.vault, quoteNodeBank.vault, dexSigner);
                transaction.add(instruction);
                transactions.push(transaction);
            }
            const signers = [];
            const transactionsAndSigners = transactions.map((tx) => ({
                transaction: tx,
                signers,
            }));
            const signedTransactions = yield this.signTransactions({
                transactionsAndSigners,
                payer: owner,
            });
            const txids = [];
            if (signedTransactions) {
                for (const signedTransaction of signedTransactions) {
                    if (signedTransaction.instructions.length == 0) {
                        continue;
                    }
                    const txid = yield this.sendSignedTransaction({
                        signedTransaction,
                    });
                    txids.push(txid);
                }
            }
            else {
                throw new Error('Unable to sign Settle All transaction');
            }
            return txids;
        });
    }
    /**
     * Automatically fetch EntropyAccounts for this PerpMarket
     * Pick enough EntropyAccounts that have opposite sign and send them in to get settled
     */
    settlePnl(entropyGroup, entropyCache, entropyAccount, perpMarket, quoteRootBank, price, // should be the EntropyCache price
        owner, entropyAccounts) {
        return __awaiter(this, void 0, void 0, function* () {
            // fetch all EntropyAccounts filtered for having this perp market in basket
            const marketIndex = entropyGroup.getPerpMarketIndex(perpMarket.publicKey);
            const perpMarketInfo = entropyGroup.perpMarkets[marketIndex];
            let pnl = entropyAccount.perpAccounts[marketIndex].getPnl(perpMarketInfo, entropyCache.perpMarketCache[marketIndex], price);
            const transaction = new web3_js_1.Transaction();
            const additionalSigners = [];
            let sign;
            if (pnl.eq(fixednum_1.ZERO_I80F48)) {
                // Can't settle pnl if there is no pnl
                return null;
            }
            else if (pnl.gt(fixednum_1.ZERO_I80F48)) {
                sign = 1;
            }
            else {
                // Can settle fees first against perpmarket
                sign = -1;
                if (!quoteRootBank.nodeBankAccounts) {
                    yield quoteRootBank.loadNodeBanks(this.connection);
                }
                const settleFeesInstr = (0, instruction_1.makeSettleFeesInstruction)(this.programId, entropyGroup.publicKey, entropyCache.publicKey, perpMarket.publicKey, entropyAccount.publicKey, quoteRootBank.publicKey, quoteRootBank.nodeBanks[0], quoteRootBank.nodeBankAccounts[0].vault, entropyGroup.feesVault, entropyGroup.signerKey);
                transaction.add(settleFeesInstr);
                pnl = pnl.add(perpMarket.feesAccrued).min(fixednum_1.I80F48.fromString('-0.000001'));
                const remSign = pnl.gt(fixednum_1.ZERO_I80F48) ? 1 : -1;
                if (remSign !== sign) {
                    // if pnl has changed sign, then we're done
                    return yield this.sendTransaction(transaction, owner, additionalSigners);
                }
            }
            if (entropyAccounts === undefined) {
                entropyAccounts = yield this.getAllEntropyAccounts(entropyGroup, [], false);
            }
            const accountsWithPnl = entropyAccounts
                .map((m) => ({
                    account: m,
                    pnl: m.perpAccounts[marketIndex].getPnl(perpMarketInfo, entropyCache.perpMarketCache[marketIndex], price),
                }))
                .sort((a, b) => sign * a.pnl.cmp(b.pnl));
            for (const account of accountsWithPnl) {
                // ignore own account explicitly
                if (account.account.publicKey.equals(entropyAccount.publicKey)) {
                    continue;
                }
                if (((pnl.isPos() && account.pnl.isNeg()) ||
                    (pnl.isNeg() && account.pnl.isPos())) &&
                    transaction.instructions.length < 10) {
                    // Account pnl must have opposite signs
                    const instr = (0, instruction_1.makeSettlePnlInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, account.account.publicKey, entropyGroup.entropyCache, quoteRootBank.publicKey, quoteRootBank.nodeBanks[0], new bn_js_1.default(marketIndex));
                    transaction.add(instr);
                    pnl = pnl.add(account.pnl);
                    // if pnl has changed sign, then we're done
                    const remSign = pnl.gt(fixednum_1.ZERO_I80F48) ? 1 : -1;
                    if (remSign !== sign) {
                        break;
                    }
                }
                else {
                    // means we ran out of accounts to settle against (shouldn't happen) OR transaction too big
                    // TODO - create a multi tx to be signed by user
                    continue;
                }
            }
            return yield this.sendTransaction(transaction, owner, additionalSigners);
            // Calculate the profit or loss per market
        });
    }
    getEntropyAccountsForOwner(entropyGroup, owner, includeOpenOrders = false) {
        const filters = [
            {
                memcmp: {
                    offset: layout_1.EntropyAccountLayout.offsetOf('owner'),
                    bytes: owner.toBase58(),
                },
            },
        ];
        return this.getAllEntropyAccounts(entropyGroup, filters, includeOpenOrders);
    }
    getAllEntropyAccounts(entropyGroup, filters, includeOpenOrders = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const accountFilters = [
                {
                    memcmp: {
                        offset: layout_1.EntropyAccountLayout.offsetOf('entropyGroup'),
                        bytes: entropyGroup.publicKey.toBase58(),
                    },
                },
                {
                    dataSize: layout_1.EntropyAccountLayout.span,
                },
            ];
            if (filters && filters.length) {
                accountFilters.push(...filters);
            }
            const entropyAccounts = yield (0, utils_1.getFilteredProgramAccounts)(this.connection, this.programId, accountFilters).then((accounts) => accounts.map(({ publicKey, accountInfo }) => {
                return new EntropyAccount_1.default(publicKey, layout_1.EntropyAccountLayout.decode(accountInfo == null ? undefined : accountInfo.data));
            }));
            if (includeOpenOrders) {
                const openOrderPks = entropyAccounts
                    .map((ma) => ma.spotOpenOrders.filter((pk) => !pk.equals(utils_1.zeroKey)))
                    .flat();
                const openOrderAccountInfos = yield (0, utils_1.getMultipleAccounts)(this.connection, openOrderPks);
                const openOrders = openOrderAccountInfos.map(({ publicKey, accountInfo }) => serum_1.OpenOrders.fromAccountInfo(publicKey, accountInfo, entropyGroup.dexProgramId));
                const pkToOpenOrdersAccount = {};
                openOrders.forEach((openOrdersAccount) => {
                    pkToOpenOrdersAccount[openOrdersAccount.publicKey.toBase58()] =
                        openOrdersAccount;
                });
                for (const ma of entropyAccounts) {
                    for (let i = 0; i < ma.spotOpenOrders.length; i++) {
                        if (ma.spotOpenOrders[i].toBase58() in pkToOpenOrdersAccount) {
                            ma.spotOpenOrdersAccounts[i] =
                                pkToOpenOrdersAccount[ma.spotOpenOrders[i].toBase58()];
                        }
                    }
                }
            }
            return entropyAccounts;
        });
    }
    addStubOracle(entropyGroupPk, admin) {
        return __awaiter(this, void 0, void 0, function* () {
            const createOracleAccountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, admin.publicKey, layout_1.StubOracleLayout.span, this.programId);
            const instruction = (0, instruction_1.makeAddOracleInstruction)(this.programId, entropyGroupPk, createOracleAccountInstruction.account.publicKey, admin.publicKey);
            const transaction = new web3_js_1.Transaction();
            transaction.add(createOracleAccountInstruction.instruction);
            transaction.add(instruction);
            const additionalSigners = [createOracleAccountInstruction.account];
            return yield this.sendTransaction(transaction, admin, additionalSigners);
        });
    }
    setStubOracle(entropyGroupPk, oraclePk, admin, price) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeSetOracleInstruction)(this.programId, entropyGroupPk, oraclePk, admin.publicKey, fixednum_1.I80F48.fromNumber(price));
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, admin, additionalSigners);
        });
    }
    addPerpMarket(entropyGroup, oraclePk, mngoMintPk, admin, maintLeverage, initLeverage, liquidationFee, makerFee, takerFee, baseLotSize, quoteLotSize, maxNumEvents, rate, // liquidity mining params; set rate == 0 if no liq mining
        maxDepthBps, targetPeriodLength, mngoPerPeriod, exp) {
        return __awaiter(this, void 0, void 0, function* () {
            const makePerpMarketAccountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, admin.publicKey, layout_1.PerpMarketLayout.span, this.programId);
            const makeEventQueueAccountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, admin.publicKey, layout_1.PerpEventQueueHeaderLayout.span + maxNumEvents * layout_1.PerpEventLayout.span, this.programId);
            const makeBidAccountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, admin.publicKey, layout_1.BookSideLayout.span, this.programId);
            const makeAskAccountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, admin.publicKey, layout_1.BookSideLayout.span, this.programId);
            const mngoVaultAccount = new web3_js_1.Account();
            const mngoVaultAccountInstructions = yield (0, utils_1.createTokenAccountInstructions)(this.connection, admin.publicKey, mngoVaultAccount.publicKey, mngoMintPk, entropyGroup.signerKey);
            const instruction = yield (0, instruction_1.makeAddPerpMarketInstruction)(this.programId, entropyGroup.publicKey, oraclePk, makePerpMarketAccountInstruction.account.publicKey, makeEventQueueAccountInstruction.account.publicKey, makeBidAccountInstruction.account.publicKey, makeAskAccountInstruction.account.publicKey, mngoVaultAccount.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumber(maintLeverage), fixednum_1.I80F48.fromNumber(initLeverage), fixednum_1.I80F48.fromNumber(liquidationFee), fixednum_1.I80F48.fromNumber(makerFee), fixednum_1.I80F48.fromNumber(takerFee), new bn_js_1.default(baseLotSize), new bn_js_1.default(quoteLotSize), fixednum_1.I80F48.fromNumber(rate), fixednum_1.I80F48.fromNumber(maxDepthBps), new bn_js_1.default(targetPeriodLength), new bn_js_1.default(mngoPerPeriod), new bn_js_1.default(exp));
            const createMngoVaultTransaction = new web3_js_1.Transaction();
            createMngoVaultTransaction.add(...mngoVaultAccountInstructions);
            yield this.sendTransaction(createMngoVaultTransaction, admin, [
                mngoVaultAccount,
            ]);
            const transaction = new web3_js_1.Transaction();
            transaction.add(makePerpMarketAccountInstruction.instruction);
            transaction.add(makeEventQueueAccountInstruction.instruction);
            transaction.add(makeBidAccountInstruction.instruction);
            transaction.add(makeAskAccountInstruction.instruction);
            transaction.add(instruction);
            const additionalSigners = [
                makePerpMarketAccountInstruction.account,
                makeEventQueueAccountInstruction.account,
                makeBidAccountInstruction.account,
                makeAskAccountInstruction.account,
            ];
            return yield this.sendTransaction(transaction, admin, additionalSigners);
        });
    }
    createPerpMarket(entropyGroup, oraclePk, mngoMintPk, admin, maintLeverage, initLeverage, liquidationFee, makerFee, takerFee, baseLotSize, quoteLotSize, maxNumEvents, rate, // liquidity mining params; set rate == 0 if no liq mining
        maxDepthBps, targetPeriodLength, mngoPerPeriod, exp, version, lmSizeShift, baseDecimals) {
        return __awaiter(this, void 0, void 0, function* () {
            const [perpMarketPk] = yield web3_js_1.PublicKey.findProgramAddress([
                entropyGroup.publicKey.toBytes(),
                new Buffer('PerpMarket', 'utf-8'),
                oraclePk.toBytes(),
            ], this.programId);
            const makeEventQueueAccountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, admin.publicKey, layout_1.PerpEventQueueHeaderLayout.span + maxNumEvents * layout_1.PerpEventLayout.span, this.programId);
            const makeBidAccountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, admin.publicKey, layout_1.BookSideLayout.span, this.programId);
            const makeAskAccountInstruction = yield (0, utils_1.createAccountInstruction)(this.connection, admin.publicKey, layout_1.BookSideLayout.span, this.programId);
            const [mngoVaultPk] = yield web3_js_1.PublicKey.findProgramAddress([
                perpMarketPk.toBytes(),
                spl_token_1.TOKEN_PROGRAM_ID.toBytes(),
                mngoMintPk.toBytes(),
            ], this.programId);
            const instruction = yield (0, instruction_1.makeCreatePerpMarketInstruction)(this.programId, entropyGroup.publicKey, oraclePk, perpMarketPk, makeEventQueueAccountInstruction.account.publicKey, makeBidAccountInstruction.account.publicKey, makeAskAccountInstruction.account.publicKey, mngoMintPk, mngoVaultPk, admin.publicKey, entropyGroup.signerKey, fixednum_1.I80F48.fromNumber(maintLeverage), fixednum_1.I80F48.fromNumber(initLeverage), fixednum_1.I80F48.fromNumber(liquidationFee), fixednum_1.I80F48.fromNumber(makerFee), fixednum_1.I80F48.fromNumber(takerFee), new bn_js_1.default(baseLotSize), new bn_js_1.default(quoteLotSize), fixednum_1.I80F48.fromNumber(rate), fixednum_1.I80F48.fromNumber(maxDepthBps), new bn_js_1.default(targetPeriodLength), new bn_js_1.default(mngoPerPeriod), new bn_js_1.default(exp), new bn_js_1.default(version), new bn_js_1.default(lmSizeShift), new bn_js_1.default(baseDecimals));
            const transaction = new web3_js_1.Transaction();
            transaction.add(makeEventQueueAccountInstruction.instruction);
            transaction.add(makeBidAccountInstruction.instruction);
            transaction.add(makeAskAccountInstruction.instruction);
            transaction.add(instruction);
            const additionalSigners = [
                makeEventQueueAccountInstruction.account,
                makeBidAccountInstruction.account,
                makeAskAccountInstruction.account,
            ];
            return yield this.sendTransaction(transaction, admin, additionalSigners);
        });
    }
    // Liquidator Functions
    forceCancelSpotOrders(entropyGroup, liqeeEntropyAccount, spotMarket, baseRootBank, quoteRootBank, payer, limit) {
        return __awaiter(this, void 0, void 0, function* () {
            const baseNodeBanks = yield baseRootBank.loadNodeBanks(this.connection);
            const quoteNodeBanks = yield quoteRootBank.loadNodeBanks(this.connection);
            const openOrdersKeys = [];
            const spotMarketIndex = entropyGroup.getSpotMarketIndex(spotMarket.publicKey);
            // Only pass in open orders if in margin basket or current market index, and
            // the only writable account should be OpenOrders for current market index
            for (let i = 0; i < liqeeEntropyAccount.spotOpenOrders.length; i++) {
                let pubkey = utils_1.zeroKey;
                let isWritable = false;
                if (i === spotMarketIndex) {
                    isWritable = true;
                    if (liqeeEntropyAccount.spotOpenOrders[spotMarketIndex].equals(utils_1.zeroKey)) {
                        console.log('missing oo for ', spotMarketIndex);
                        // open orders missing for this market; create a new one now
                        // const openOrdersSpace = OpenOrders.getLayout(
                        //   entropyGroup.dexProgramId,
                        // ).span;
                        // const openOrdersLamports =
                        //   await this.connection.getMinimumBalanceForRentExemption(
                        //     openOrdersSpace,
                        //     'singleGossip',
                        //   );
                        // const accInstr = await createAccountInstruction(
                        //   this.connection,
                        //   owner.publicKey,
                        //   openOrdersSpace,
                        //   entropyGroup.dexProgramId,
                        //   openOrdersLamports,
                        // );
                        // transaction.add(accInstr.instruction);
                        // additionalSigners.push(accInstr.account);
                        // pubkey = accInstr.account.publicKey;
                    }
                    else {
                        pubkey = liqeeEntropyAccount.spotOpenOrders[i];
                    }
                }
                else if (liqeeEntropyAccount.inMarginBasket[i]) {
                    pubkey = liqeeEntropyAccount.spotOpenOrders[i];
                }
                openOrdersKeys.push({ pubkey, isWritable });
            }
            const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([
                spotMarket.publicKey.toBuffer(),
                spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),
            ], spotMarket.programId);
            const instruction = (0, instruction_1.makeForceCancelSpotOrdersInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, liqeeEntropyAccount.publicKey, baseRootBank.publicKey, baseNodeBanks[0].publicKey, baseNodeBanks[0].vault, quoteRootBank.publicKey, quoteNodeBanks[0].publicKey, quoteNodeBanks[0].vault, spotMarket.publicKey, spotMarket.bidsAddress, spotMarket.asksAddress, entropyGroup.signerKey, spotMarket['_decoded'].eventQueue, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, dexSigner, entropyGroup.dexProgramId, openOrdersKeys, limit);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    /**
     * Send multiple instructions to cancel all perp orders in this market
     */
    forceCancelAllPerpOrdersInMarket(entropyGroup, liqee, perpMarket, payer, limitPerInstruction) {
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = new web3_js_1.Transaction();
            const marketIndex = entropyGroup.getPerpMarketIndex(perpMarket.publicKey);
            const instruction = (0, instruction_1.makeForceCancelPerpOrdersInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, liqee.publicKey, liqee.spotOpenOrders, new bn_js_1.default(limitPerInstruction));
            transaction.add(instruction);
            let orderCount = 0;
            for (let i = 0; i < liqee.orderMarket.length; i++) {
                if (liqee.orderMarket[i] !== marketIndex) {
                    continue;
                }
                orderCount++;
                if (orderCount === limitPerInstruction) {
                    orderCount = 0;
                    const instruction = (0, instruction_1.makeForceCancelPerpOrdersInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, liqee.publicKey, liqee.spotOpenOrders, new bn_js_1.default(limitPerInstruction));
                    transaction.add(instruction);
                    // TODO - verify how many such instructions can go into one tx
                    // right now 10 seems reasonable considering size of 800ish bytes if all spot open orders present
                    if (transaction.instructions.length === 10) {
                        break;
                    }
                }
            }
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    forceCancelPerpOrders(entropyGroup, liqeeEntropyAccount, perpMarket, payer, limit) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeForceCancelPerpOrdersInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, liqeeEntropyAccount.publicKey, liqeeEntropyAccount.spotOpenOrders, limit);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    liquidateTokenAndToken(entropyGroup, liqeeEntropyAccount, liqorEntropyAccount, assetRootBank, liabRootBank, payer, maxLiabTransfer) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeLiquidateTokenAndTokenInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, liqeeEntropyAccount.publicKey, liqorEntropyAccount.publicKey, payer.publicKey, assetRootBank.publicKey, assetRootBank.nodeBanks[0], liabRootBank.publicKey, liabRootBank.nodeBanks[0], liqeeEntropyAccount.spotOpenOrders, liqorEntropyAccount.spotOpenOrders, maxLiabTransfer);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    liquidateTokenAndPerp(entropyGroup, liqeeEntropyAccount, liqorEntropyAccount, rootBank, payer, assetType, assetIndex, liabType, liabIndex, maxLiabTransfer) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeLiquidateTokenAndPerpInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, liqeeEntropyAccount.publicKey, liqorEntropyAccount.publicKey, payer.publicKey, rootBank.publicKey, rootBank.nodeBanks[0], liqeeEntropyAccount.spotOpenOrders, liqorEntropyAccount.spotOpenOrders, assetType, new bn_js_1.default(assetIndex), liabType, new bn_js_1.default(liabIndex), maxLiabTransfer);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    liquidatePerpMarket(entropyGroup, liqeeEntropyAccount, liqorEntropyAccount, perpMarket, payer, baseTransferRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeLiquidatePerpMarketInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, perpMarket.publicKey, perpMarket.eventQueue, liqeeEntropyAccount.publicKey, liqorEntropyAccount.publicKey, payer.publicKey, liqeeEntropyAccount.spotOpenOrders, liqorEntropyAccount.spotOpenOrders, baseTransferRequest);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    settleFees(entropyGroup, entropyAccount, perpMarket, rootBank, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            const nodeBanks = yield rootBank.loadNodeBanks(this.connection);
            const instruction = (0, instruction_1.makeSettleFeesInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, perpMarket.publicKey, entropyAccount.publicKey, rootBank.publicKey, nodeBanks[0].publicKey, nodeBanks[0].vault, entropyGroup.feesVault, entropyGroup.signerKey);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    resolvePerpBankruptcy(entropyGroup, liqeeEntropyAccount, liqorEntropyAccount, perpMarket, rootBank, payer, liabIndex, maxLiabTransfer) {
        return __awaiter(this, void 0, void 0, function* () {
            const nodeBanks = yield rootBank.loadNodeBanks(this.connection);
            const instruction = (0, instruction_1.makeResolvePerpBankruptcyInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, liqeeEntropyAccount.publicKey, liqorEntropyAccount.publicKey, payer.publicKey, rootBank.publicKey, nodeBanks[0].publicKey, nodeBanks[0].vault, entropyGroup.insuranceVault, entropyGroup.signerKey, perpMarket.publicKey, liqorEntropyAccount.spotOpenOrders, new bn_js_1.default(liabIndex), maxLiabTransfer);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    resolveTokenBankruptcy(entropyGroup, liqeeEntropyAccount, liqorEntropyAccount, quoteRootBank, liabRootBank, payer, maxLiabTransfer) {
        return __awaiter(this, void 0, void 0, function* () {
            const quoteNodeBanks = yield quoteRootBank.loadNodeBanks(this.connection);
            const instruction = (0, instruction_1.makeResolveTokenBankruptcyInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, liqeeEntropyAccount.publicKey, liqorEntropyAccount.publicKey, payer.publicKey, quoteRootBank.publicKey, quoteRootBank.nodeBanks[0], quoteNodeBanks[0].vault, entropyGroup.insuranceVault, entropyGroup.signerKey, liabRootBank.publicKey, liabRootBank.nodeBanks[0], liqorEntropyAccount.spotOpenOrders, liabRootBank.nodeBanks, maxLiabTransfer);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    redeemMngo(entropyGroup, entropyAccount, perpMarket, payer, mngoRootBank, mngoNodeBank, mngoVault) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeRedeemMngoInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, entropyAccount.publicKey, payer.publicKey, perpMarket.publicKey, perpMarket.mngoVault, mngoRootBank, mngoNodeBank, mngoVault, entropyGroup.signerKey);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            return yield this.sendTransaction(transaction, payer, []);
        });
    }
    redeemAllMngo(entropyGroup, entropyAccount, payer, mngoRootBank, mngoNodeBank, mngoVault) {
        return __awaiter(this, void 0, void 0, function* () {
            const transactions = [];
            let transaction = new web3_js_1.Transaction();
            const perpMarkets = yield Promise.all(entropyAccount.perpAccounts.map((perpAccount, i) => {
                if (perpAccount.mngoAccrued.eq(utils_1.ZERO_BN)) {
                    return (0, utils_1.promiseUndef)();
                }
                else {
                    return this.getPerpMarket(entropyGroup.perpMarkets[i].perpMarket, entropyGroup.tokens[i].decimals, entropyGroup.tokens[layout_1.QUOTE_INDEX].decimals);
                }
            }));
            for (let i = 0; i < entropyAccount.perpAccounts.length; i++) {
                const perpMarket = perpMarkets[i];
                if (perpMarket === undefined)
                    continue;
                const instruction = (0, instruction_1.makeRedeemMngoInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, entropyAccount.publicKey, payer.publicKey, perpMarket.publicKey, perpMarket.mngoVault, mngoRootBank, mngoNodeBank, mngoVault, entropyGroup.signerKey);
                transaction.add(instruction);
                if (transaction.instructions.length === 9) {
                    transactions.push(transaction);
                    transaction = new web3_js_1.Transaction();
                }
            }
            if (transaction.instructions.length > 0) {
                transactions.push(transaction);
                // txProms.push(this.sendTransaction(transaction, payer, []));
            }
            const transactionsAndSigners = transactions.map((tx) => ({
                transaction: tx,
                signers: [],
            }));
            if (transactionsAndSigners.length === 0) {
                throw new Error('No MNGO rewards to redeem');
            }
            // Sign multiple transactions at once for better UX
            const signedTransactions = yield this.signTransactions({
                transactionsAndSigners,
                payer,
            });
            if (signedTransactions) {
                const txSigs = yield Promise.all(signedTransactions.map((signedTransaction) => this.sendSignedTransaction({ signedTransaction })));
                return txSigs[0];
            }
            else {
                throw new Error('Unable to sign all RedeemMngo transactions');
            }
        });
    }
    addEntropyAccountInfo(entropyGroup, entropyAccount, owner, info) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeAddEntropyAccountInfoInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, info);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, owner, additionalSigners);
        });
    }
    depositMsrm(entropyGroup, entropyAccount, owner, msrmAccount, quantity) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeDepositMsrmInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, msrmAccount, entropyGroup.msrmVault, new bn_js_1.default(Math.floor(quantity)));
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, owner, additionalSigners);
        });
    }
    withdrawMsrm(entropyGroup, entropyAccount, owner, msrmAccount, quantity) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeWithdrawMsrmInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, msrmAccount, entropyGroup.msrmVault, entropyGroup.signerKey, new bn_js_1.default(Math.floor(quantity)));
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, owner, additionalSigners);
        });
    }
    changePerpMarketParams(entropyGroup, perpMarket, admin, maintLeverage, initLeverage, liquidationFee, makerFee, takerFee, rate, maxDepthBps, targetPeriodLength, mngoPerPeriod, exp) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeChangePerpMarketParamsInstruction)(this.programId, entropyGroup.publicKey, perpMarket.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumberOrUndef(maintLeverage), fixednum_1.I80F48.fromNumberOrUndef(initLeverage), fixednum_1.I80F48.fromNumberOrUndef(liquidationFee), fixednum_1.I80F48.fromNumberOrUndef(makerFee), fixednum_1.I80F48.fromNumberOrUndef(takerFee), fixednum_1.I80F48.fromNumberOrUndef(rate), fixednum_1.I80F48.fromNumberOrUndef(maxDepthBps), targetPeriodLength !== undefined ? new bn_js_1.default(targetPeriodLength) : undefined, mngoPerPeriod !== undefined ? new bn_js_1.default(mngoPerPeriod) : undefined, exp !== undefined ? new bn_js_1.default(exp) : undefined);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, admin, additionalSigners);
        });
    }
    changePerpMarketParams2(entropyGroup, perpMarket, admin, maintLeverage, initLeverage, liquidationFee, makerFee, takerFee, rate, maxDepthBps, targetPeriodLength, mngoPerPeriod, exp, version, lmSizeShift) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeChangePerpMarketParams2Instruction)(this.programId, entropyGroup.publicKey, perpMarket.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumberOrUndef(maintLeverage), fixednum_1.I80F48.fromNumberOrUndef(initLeverage), fixednum_1.I80F48.fromNumberOrUndef(liquidationFee), fixednum_1.I80F48.fromNumberOrUndef(makerFee), fixednum_1.I80F48.fromNumberOrUndef(takerFee), fixednum_1.I80F48.fromNumberOrUndef(rate), fixednum_1.I80F48.fromNumberOrUndef(maxDepthBps), targetPeriodLength !== undefined ? new bn_js_1.default(targetPeriodLength) : undefined, mngoPerPeriod !== undefined ? new bn_js_1.default(mngoPerPeriod) : undefined, exp !== undefined ? new bn_js_1.default(exp) : undefined, version !== undefined ? new bn_js_1.default(version) : undefined, lmSizeShift !== undefined ? new bn_js_1.default(lmSizeShift) : undefined);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, admin, additionalSigners);
        });
    }
    setGroupAdmin(entropyGroup, newAdmin, admin) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeSetGroupAdminInstruction)(this.programId, entropyGroup.publicKey, newAdmin, admin.publicKey);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, admin, additionalSigners);
        });
    }
    /**
     * Add allowance for orders to be cancelled and replaced in a single transaction
     */
    modifySpotOrder(entropyGroup, entropyAccount, entropyCache, spotMarket, owner, order, side, price, size, orderType) {
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = new web3_js_1.Transaction();
            const instruction = (0, instruction_1.makeCancelSpotOrderInstruction)(this.programId, entropyGroup.publicKey, owner.publicKey, entropyAccount.publicKey, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, order.openOrdersAddress, entropyGroup.signerKey, spotMarket['_decoded'].eventQueue, order);
            transaction.add(instruction);
            const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([
                spotMarket.publicKey.toBuffer(),
                spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),
            ], spotMarket.programId);
            const spotMarketIndex = entropyGroup.getSpotMarketIndex(spotMarket.publicKey);
            if (!entropyGroup.rootBankAccounts.length) {
                yield entropyGroup.loadRootBanks(this.connection);
            }
            const baseRootBank = entropyGroup.rootBankAccounts[spotMarketIndex];
            const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];
            const quoteRootBank = entropyGroup.rootBankAccounts[layout_1.QUOTE_INDEX];
            const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];
            if (!baseNodeBank || !quoteNodeBank) {
                throw new Error('Invalid or missing node banks');
            }
            const settleFundsInstruction = (0, instruction_1.makeSettleFundsInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, owner.publicKey, entropyAccount.publicKey, spotMarket.programId, spotMarket.publicKey, entropyAccount.spotOpenOrders[spotMarketIndex], entropyGroup.signerKey, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, entropyGroup.tokens[spotMarketIndex].rootBank, baseNodeBank.publicKey, entropyGroup.tokens[layout_1.QUOTE_INDEX].rootBank, quoteNodeBank.publicKey, baseNodeBank.vault, quoteNodeBank.vault, dexSigner);
            transaction.add(settleFundsInstruction);
            const additionalSigners = [];
            const limitPrice = spotMarket.priceNumberToLots(price);
            const maxBaseQuantity = spotMarket.baseSizeNumberToLots(size);
            // TODO implement srm vault fee discount
            // const feeTier = getFeeTier(0, nativeToUi(entropyGroup.nativeSrm || 0, SRM_DECIMALS));
            const feeTier = (0, serum_1.getFeeTier)(0, (0, utils_1.nativeToUi)(0, 0));
            const rates = (0, serum_1.getFeeRates)(feeTier);
            const maxQuoteQuantity = new bn_js_1.default(spotMarket['_decoded'].quoteLotSize.toNumber() * (1 + rates.taker)).mul(spotMarket
                .baseSizeNumberToLots(size)
                .mul(spotMarket.priceNumberToLots(price)));
            // Checks already completed as only price modified
            if (maxBaseQuantity.lte(utils_1.ZERO_BN)) {
                throw new Error('size too small');
            }
            if (limitPrice.lte(utils_1.ZERO_BN)) {
                throw new Error('invalid price');
            }
            const selfTradeBehavior = 'decrementTake';
            if (!baseRootBank || !baseNodeBank || !quoteRootBank || !quoteNodeBank) {
                throw new Error('Invalid or missing banks');
            }
            const openOrdersKeys = [];
            // Only pass in open orders if in margin basket or current market index, and
            // the only writable account should be OpenOrders for current market index
            for (let i = 0; i < entropyAccount.spotOpenOrders.length; i++) {
                let pubkey = utils_1.zeroKey;
                let isWritable = false;
                if (i === spotMarketIndex) {
                    isWritable = true;
                    if (entropyAccount.spotOpenOrders[spotMarketIndex].equals(utils_1.zeroKey)) {
                        // open orders missing for this market; create a new one now
                        const openOrdersSpace = serum_1.OpenOrders.getLayout(entropyGroup.dexProgramId).span;
                        const openOrdersLamports = yield this.connection.getMinimumBalanceForRentExemption(openOrdersSpace, 'confirmed');
                        const accInstr = yield (0, utils_1.createAccountInstruction)(this.connection, owner.publicKey, openOrdersSpace, entropyGroup.dexProgramId, openOrdersLamports);
                        const initOpenOrders = (0, instruction_1.makeInitSpotOpenOrdersInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, entropyGroup.dexProgramId, accInstr.account.publicKey, spotMarket.publicKey, entropyGroup.signerKey);
                        const initTx = new web3_js_1.Transaction();
                        initTx.add(accInstr.instruction);
                        initTx.add(initOpenOrders);
                        yield this.sendTransaction(initTx, owner, [accInstr.account]);
                        pubkey = accInstr.account.publicKey;
                    }
                    else {
                        pubkey = entropyAccount.spotOpenOrders[i];
                    }
                }
                else if (entropyAccount.inMarginBasket[i]) {
                    pubkey = entropyAccount.spotOpenOrders[i];
                }
                openOrdersKeys.push({ pubkey, isWritable });
            }
            const placeOrderInstruction = (0, instruction_1.makePlaceSpotOrderInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, entropyCache, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, spotMarket['_decoded'].requestQueue, spotMarket['_decoded'].eventQueue, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, baseRootBank.publicKey, baseNodeBank.publicKey, baseNodeBank.vault, quoteRootBank.publicKey, quoteNodeBank.publicKey, quoteNodeBank.vault, entropyGroup.signerKey, dexSigner, entropyGroup.srmVault, // TODO: choose msrm vault if it has any deposits
                openOrdersKeys, side, limitPrice, maxBaseQuantity, maxQuoteQuantity, selfTradeBehavior, orderType, order.clientId);
            transaction.add(placeOrderInstruction);
            if (spotMarketIndex > 0) {
                console.log(new Date().toISOString(), spotMarketIndex - 1, entropyAccount.spotOpenOrders[spotMarketIndex - 1].toBase58(), openOrdersKeys[spotMarketIndex - 1].pubkey.toBase58());
            }
            const txid = yield this.sendTransaction(transaction, owner, additionalSigners);
            // update EntropyAccount to have new OpenOrders pubkey
            entropyAccount.spotOpenOrders[spotMarketIndex] =
                openOrdersKeys[spotMarketIndex].pubkey;
            entropyAccount.inMarginBasket[spotMarketIndex] = true;
            console.log(new Date().toISOString(), spotMarketIndex, entropyAccount.spotOpenOrders[spotMarketIndex].toBase58(), openOrdersKeys[spotMarketIndex].pubkey.toBase58());
            return txid;
        });
    }
    modifyPerpOrder(entropyGroup, entropyAccount, entropyCache, perpMarket, owner, order, side, price, quantity, orderType, clientOrderId, bookSideInfo, // ask if side === bid, bids if side === ask; if this is given; crank instruction is added
        invalidIdOk = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = new web3_js_1.Transaction();
            const additionalSigners = [];
            const cancelInstruction = (0, instruction_1.makeCancelPerpOrderInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, order, invalidIdOk);
            transaction.add(cancelInstruction);
            const [nativePrice, nativeQuantity] = perpMarket.uiToNativePriceQuantity(price, quantity);
            const placeInstruction = (0, instruction_1.makePlacePerpOrderInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, entropyCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, perpMarket.eventQueue, entropyAccount.spotOpenOrders, nativePrice, nativeQuantity, clientOrderId
                ? new bn_js_1.default(clientOrderId)
                : (_a = order.clientId) !== null && _a !== void 0 ? _a : new bn_js_1.default(Date.now()), side, orderType);
            transaction.add(placeInstruction);
            if (bookSideInfo) {
                const bookSide = bookSideInfo.data
                    ? new book_1.BookSide(side === 'buy' ? perpMarket.asks : perpMarket.bids, perpMarket, layout_1.BookSideLayout.decode(bookSideInfo.data))
                    : [];
                const accounts = new Set();
                accounts.add(entropyAccount.publicKey.toBase58());
                for (const order of bookSide) {
                    accounts.add(order.owner.toBase58());
                    if (accounts.size >= 10) {
                        break;
                    }
                }
                const consumeInstruction = (0, instruction_1.makeConsumeEventsInstruction)(this.programId, entropyGroup.publicKey, entropyGroup.entropyCache, perpMarket.publicKey, perpMarket.eventQueue, Array.from(accounts)
                    .map((s) => new web3_js_1.PublicKey(s))
                    .sort(), new bn_js_1.default(4));
                transaction.add(consumeInstruction);
            }
            return yield this.sendTransaction(transaction, owner, additionalSigners);
        });
    }
    addPerpTriggerOrder(entropyGroup, entropyAccount, perpMarket, owner, orderType, side, price, quantity, triggerCondition, triggerPrice, reduceOnly, clientOrderId) {
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = new web3_js_1.Transaction();
            const additionalSigners = [];
            let advancedOrders = entropyAccount.advancedOrdersKey;
            if (entropyAccount.advancedOrdersKey.equals(utils_1.zeroKey)) {
                [advancedOrders] = yield web3_js_1.PublicKey.findProgramAddress([entropyAccount.publicKey.toBytes()], this.programId);
                console.log(new Date().toISOString(), 'AdvancedOrders PDA:', advancedOrders.toBase58());
                transaction.add((0, instruction_1.makeInitAdvancedOrdersInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, advancedOrders));
            }
            const marketIndex = entropyGroup.getPerpMarketIndex(perpMarket.publicKey);
            const baseTokenInfo = entropyGroup.tokens[marketIndex];
            const quoteTokenInfo = entropyGroup.tokens[layout_1.QUOTE_INDEX];
            const baseUnit = Math.pow(10, baseTokenInfo.decimals);
            const quoteUnit = Math.pow(10, quoteTokenInfo.decimals);
            const nativePrice = new bn_js_1.default(price * quoteUnit)
                .mul(perpMarket.baseLotSize)
                .div(perpMarket.quoteLotSize.mul(new bn_js_1.default(baseUnit)));
            const nativeQuantity = new bn_js_1.default(quantity * baseUnit).div(perpMarket.baseLotSize);
            const nativeTriggerPrice = fixednum_1.I80F48.fromNumber(triggerPrice *
                Math.pow(10, perpMarket.quoteDecimals - perpMarket.baseDecimals));
            const openOrders = entropyAccount.spotOpenOrders.filter((pk, i) => entropyAccount.inMarginBasket[i]);
            transaction.add((0, instruction_1.makeAddPerpTriggerOrderInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, advancedOrders, entropyGroup.entropyCache, perpMarket.publicKey, openOrders, orderType, side, nativePrice, nativeQuantity, triggerCondition, nativeTriggerPrice, reduceOnly, new bn_js_1.default(clientOrderId !== null && clientOrderId !== void 0 ? clientOrderId : Date.now())));
            const txid = yield this.sendTransaction(transaction, owner, additionalSigners);
            entropyAccount.advancedOrdersKey = advancedOrders;
            return txid;
        });
    }
    removeAdvancedOrder(entropyGroup, entropyAccount, owner, orderIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeRemoveAdvancedOrderInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, owner.publicKey, entropyAccount.advancedOrdersKey, orderIndex);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, owner, additionalSigners);
        });
    }
    executePerpTriggerOrder(entropyGroup, entropyAccount, entropyCache, perpMarket, payer, orderIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            const openOrders = entropyAccount.spotOpenOrders.filter((pk, i) => entropyAccount.inMarginBasket[i]);
            const instruction = (0, instruction_1.makeExecutePerpTriggerOrderInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, entropyAccount.advancedOrdersKey, payer.publicKey, entropyCache.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, perpMarket.eventQueue, openOrders, new bn_js_1.default(orderIndex));
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, payer, additionalSigners);
        });
    }
    updateMarginBasket(entropyGroup, entropyAccount, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            const instruction = (0, instruction_1.makeUpdateMarginBasketInstruction)(this.programId, entropyGroup.publicKey, entropyAccount.publicKey, entropyAccount.spotOpenOrders);
            const transaction = new web3_js_1.Transaction();
            transaction.add(instruction);
            const additionalSigners = [];
            return yield this.sendTransaction(transaction, payer, additionalSigners);
        });
    }
}
exports.EntropyClient = EntropyClient;
//# sourceMappingURL=client.js.map