/// <reference types="node" />
import { Account, AccountInfo, Commitment, Connection, Keypair, PublicKey, Transaction, TransactionConfirmationStatus, TransactionSignature } from '@solana/web3.js';
import BN from 'bn.js';
import { AssetType, EntropyCache } from './layout';
import EntropyAccount from './EntropyAccount';
import PerpMarket from './PerpMarket';
import RootBank from './RootBank';
import { Market } from '@project-serum/serum';
import { I80F48 } from './fixednum';
import { Order } from '@project-serum/serum/lib/market';
import { PerpOrderType, WalletAdapter, BlockhashTimes } from './types';
import { PerpOrder } from './book';
import EntropyGroup from './EntropyGroup';
export declare const getUnixTs: () => number;
/**
 * A class for interacting with the Entropy V3 Program
 *
 * @param connection A solana web.js Connection object
 * @param programId The PublicKey of the Entropy V3 Program
 * @param opts An object used to configure the EntropyClient. Accepts a postSendTxCallback
 */
export declare class EntropyClient {
    connection: Connection;
    programId: PublicKey;
    lastSlot: number;
    recentBlockhash: string;
    recentBlockhashTime: number;
    maxStoredBlockhashes: number;
    timeout: number | null;
    blockhashCommitment: Commitment;
    postSendTxCallback?: ({ txid: string }: {
        txid: any;
    }) => void;
    constructor(connection: Connection, programId: PublicKey, opts?: {
        postSendTxCallback?: ({ txid }: {
            txid: string;
        }) => void;
        maxStoredBlockhashes?: number;
        blockhashCommitment?: Commitment;
        timeout?: number;
    });
    sendTransactions(transactions: Transaction[], payer: Account | WalletAdapter, additionalSigners: Account[], timeout?: number, confirmLevel?: TransactionConfirmationStatus): Promise<TransactionSignature[]>;
    signTransaction({ transaction, payer, signers }: {
        transaction: any;
        payer: any;
        signers: any;
    }): Promise<any>;
    signTransactions({ transactionsAndSigners, payer, }: {
        transactionsAndSigners: {
            transaction: Transaction;
            signers?: Array<Account>;
        }[];
        payer: Account | WalletAdapter;
    }): Promise<Transaction[] | undefined>;
    /**
     * Send a transaction using the Solana Web3.js connection on the entropy client
     *
     * @param transaction
     * @param payer
     * @param additionalSigners
     * @param timeout Retries sending the transaction and trying to confirm it until the given timeout. Defaults to 60000ms. Passing null will disable the transaction confirmation check and always return success.
     */
    sendTransaction(transaction: Transaction, payer: Account | WalletAdapter | Keypair, additionalSigners: Account[], timeout?: number | null, confirmLevel?: TransactionConfirmationStatus, marketName?: string | null): Promise<TransactionSignature>;
    sendSignedTransaction({ signedTransaction, timeout, confirmLevel, }: {
        signedTransaction: Transaction;
        timeout?: number;
        confirmLevel?: TransactionConfirmationStatus;
    }): Promise<TransactionSignature>;
    awaitTransactionSignatureConfirmation(txid: TransactionSignature, timeout: number, confirmLevel: TransactionConfirmationStatus): Promise<unknown>;
    updateRecentBlockhash(blockhashTimes: BlockhashTimes[]): Promise<void>;
    /**
     * Maintain a timeout of 30 seconds
     * @param client
     */
    maintainTimeouts(): Promise<void>;
    /**
     * Create a new Entropy group
     */
    initEntropyGroup(quoteMint: PublicKey, msrmMint: PublicKey, dexProgram: PublicKey, feesVault: PublicKey, // owned by Entropy DAO token governance
    validInterval: number, quoteOptimalUtil: number, quoteOptimalRate: number, quoteMaxRate: number, payer: Account | WalletAdapter): Promise<PublicKey>;
    /**
     * Retrieve information about a Entropy Group
     */
    getEntropyGroup(entropyGroup: PublicKey): Promise<EntropyGroup>;
    /**
     * Create a new Entropy Account on a given group
     */
    initEntropyAccount(entropyGroup: EntropyGroup, owner: Account | WalletAdapter): Promise<PublicKey>;
    /**
     * Retrieve information about a Entropy Account
     */
    getEntropyAccount(entropyAccountPk: PublicKey, dexProgramId: PublicKey): Promise<EntropyAccount>;
    /**
     * Create a new Entropy Account and deposit some tokens in a single transaction
     *
     * @param rootBank The RootBank for the deposit currency
     * @param nodeBank The NodeBank asociated with the RootBank
     * @param vault The token account asociated with the NodeBank
     * @param tokenAcc The token account to transfer from
     * @param info An optional UI name for the account
     */
    initEntropyAccountAndDeposit(entropyGroup: EntropyGroup, owner: Account | WalletAdapter, rootBank: PublicKey, nodeBank: PublicKey, vault: PublicKey, tokenAcc: PublicKey, quantity: number, info?: string): Promise<string>;
    /**
     * Deposit tokens in a Entropy Account
     *
     * @param rootBank The RootBank for the deposit currency
     * @param nodeBank The NodeBank asociated with the RootBank
     * @param vault The token account asociated with the NodeBank
     * @param tokenAcc The token account to transfer from
     */
    deposit(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, owner: Account | WalletAdapter, rootBank: PublicKey, nodeBank: PublicKey, vault: PublicKey, tokenAcc: PublicKey, quantity: number): Promise<TransactionSignature>;
    /**
     * Deposit tokens in a Entropy Account
     *
     * @param rootBank The RootBank for the withdrawn currency
     * @param nodeBank The NodeBank asociated with the RootBank
     * @param vault The token account asociated with the NodeBank
     * @param allowBorrow Whether to borrow tokens if there are not enough deposits for the withdrawal
     */
    withdraw(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, owner: Account | WalletAdapter, rootBank: PublicKey, nodeBank: PublicKey, vault: PublicKey, quantity: number, allowBorrow: boolean): Promise<TransactionSignature>;
    changeMaxAccounts(entropyGroupPk: PublicKey, admin: Account, numAccounts: BN): Promise<string>;
    /**
     * Called by the Keeper to cache interest rates from the RootBanks
     */
    cacheRootBanks(entropyGroup: PublicKey, entropyCache: PublicKey, rootBanks: PublicKey[], payer: Account | WalletAdapter): Promise<TransactionSignature>;
    /**
     * Called by the Keeper to cache prices from the Oracles
     */
    cachePrices(entropyGroup: PublicKey, entropyCache: PublicKey, oracles: PublicKey[], payer: Account | WalletAdapter): Promise<TransactionSignature>;
    /**
     * Called by the Keeper to cache perp market funding
     */
    cachePerpMarkets(entropyGroup: PublicKey, entropyCache: PublicKey, perpMarkets: PublicKey[], payer: Account): Promise<TransactionSignature>;
    /**
     * Called by the Keeper to update interest rates on the RootBanks
     */
    updateRootBank(entropyGroup: EntropyGroup, rootBank: PublicKey, nodeBanks: PublicKey[], payer: Account | WalletAdapter): Promise<TransactionSignature>;
    /**
     * Called by the Keeper to process events on the Perp order book
     */
    consumeEvents(entropyGroup: EntropyGroup, perpMarket: PerpMarket, entropyAccounts: PublicKey[], payer: Account, limit: BN): Promise<TransactionSignature>;
    /**
     * Called by the Keeper to update funding on the perp markets
     */
    updateFunding(entropyGroup: PublicKey, entropyCache: PublicKey, perpMarket: PublicKey, bids: PublicKey, asks: PublicKey, payer: Account): Promise<TransactionSignature>;
    /**
     * Retrieve information about a perp market
     */
    getPerpMarket(perpMarketPk: PublicKey, baseDecimal: number, quoteDecimal: number): Promise<PerpMarket>;
    /**
     * Place an order on a perp market
     *
     * @param clientOrderId An optional id that can be used to correlate events related to your order
     * @param bookSideInfo Account info for asks if side === bid, bids if side === ask. If this is given, crank instruction is added
     */
    placePerpOrder(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, entropyCache: PublicKey, // TODO - remove; already in EntropyGroup
    perpMarket: PerpMarket, owner: Account | WalletAdapter, side: 'buy' | 'sell', price: number, quantity: number, orderType?: PerpOrderType, clientOrderId?: number, bookSideInfo?: AccountInfo<Buffer>, reduceOnly?: boolean): Promise<TransactionSignature>;
    /**
     * Cancel an order on a perp market
     *
     * @param invalidIdOk Don't throw error if order is invalid
     */
    cancelPerpOrder(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, owner: Account | WalletAdapter, perpMarket: PerpMarket, order: PerpOrder, invalidIdOk?: boolean): Promise<TransactionSignature>;
    /**
     * Cancel all perp orders across all markets
     */
    cancelAllPerpOrders(group: EntropyGroup, perpMarkets: PerpMarket[], entropyAccount: EntropyAccount, owner: Account | WalletAdapter): Promise<TransactionSignature[]>;
    /**
     * Add a new oracle to a group
     */
    addOracle(entropyGroup: EntropyGroup, oracle: PublicKey, admin: Account): Promise<TransactionSignature>;
    /**
     * Set the price of a 'stub' type oracle
     */
    setOracle(entropyGroup: EntropyGroup, oracle: PublicKey, admin: Account, price: I80F48): Promise<TransactionSignature>;
    addSpotMarket(entropyGroup: EntropyGroup, oracle: PublicKey, spotMarket: PublicKey, mint: PublicKey, admin: Account, maintLeverage: number, initLeverage: number, liquidationFee: number, optimalUtil: number, optimalRate: number, maxRate: number): Promise<TransactionSignature>;
    /**
     * Make sure entropyAccount has recent and valid inMarginBasket and spotOpenOrders
     */
    placeSpotOrder(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, entropyCache: PublicKey, spotMarket: Market, owner: Account | WalletAdapter, side: 'buy' | 'sell', price: number, size: number, orderType?: 'limit' | 'ioc' | 'postOnly', clientId?: BN): Promise<TransactionSignature>;
    /**
     * Make sure entropyAccount has recent and valid inMarginBasket and spotOpenOrders
     */
    placeSpotOrder2(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, spotMarket: Market, owner: Account | WalletAdapter, side: 'buy' | 'sell', price: number, size: number, orderType?: 'limit' | 'ioc' | 'postOnly', clientOrderId?: BN, useMsrmVault?: boolean | undefined): Promise<TransactionSignature>;
    cancelSpotOrder(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, owner: Account | WalletAdapter, spotMarket: Market, order: Order): Promise<TransactionSignature>;
    settleFunds(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, owner: Account | WalletAdapter, spotMarket: Market): Promise<TransactionSignature>;
    /**
     * Assumes spotMarkets contains all Markets in EntropyGroup in order
     */
    settleAll(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, spotMarkets: Market[], owner: Account | WalletAdapter): Promise<TransactionSignature[]>;
    /**
     * Automatically fetch EntropyAccounts for this PerpMarket
     * Pick enough EntropyAccounts that have opposite sign and send them in to get settled
     */
    settlePnl(entropyGroup: EntropyGroup, entropyCache: EntropyCache, entropyAccount: EntropyAccount, perpMarket: PerpMarket, quoteRootBank: RootBank, price: I80F48, // should be the EntropyCache price
    owner: Account | WalletAdapter, entropyAccounts?: EntropyAccount[]): Promise<TransactionSignature | null>;
    getEntropyAccountsForOwner(entropyGroup: EntropyGroup, owner: PublicKey, includeOpenOrders?: boolean): Promise<EntropyAccount[]>;
    getAllEntropyAccounts(entropyGroup: EntropyGroup, filters?: any[], includeOpenOrders?: boolean): Promise<EntropyAccount[]>;
    addStubOracle(entropyGroupPk: PublicKey, admin: Account): Promise<string>;
    setStubOracle(entropyGroupPk: PublicKey, oraclePk: PublicKey, admin: Account, price: number): Promise<string>;
    addPerpMarket(entropyGroup: EntropyGroup, oraclePk: PublicKey, mngoMintPk: PublicKey, admin: Account, maintLeverage: number, initLeverage: number, liquidationFee: number, makerFee: number, takerFee: number, baseLotSize: number, quoteLotSize: number, maxNumEvents: number, rate: number, // liquidity mining params; set rate == 0 if no liq mining
    maxDepthBps: number, targetPeriodLength: number, mngoPerPeriod: number, exp: number): Promise<string>;
    createPerpMarket(entropyGroup: EntropyGroup, oraclePk: PublicKey, mngoMintPk: PublicKey, admin: Account | Keypair, maintLeverage: number, initLeverage: number, liquidationFee: number, makerFee: number, takerFee: number, baseLotSize: number, quoteLotSize: number, maxNumEvents: number, rate: number, // liquidity mining params; set rate == 0 if no liq mining
    maxDepthBps: number, targetPeriodLength: number, mngoPerPeriod: number, exp: number, version: number, lmSizeShift: number, baseDecimals: number): Promise<string>;
    forceCancelSpotOrders(entropyGroup: EntropyGroup, liqeeEntropyAccount: EntropyAccount, spotMarket: Market, baseRootBank: RootBank, quoteRootBank: RootBank, payer: Account, limit: BN): Promise<string>;
    /**
     * Send multiple instructions to cancel all perp orders in this market
     */
    forceCancelAllPerpOrdersInMarket(entropyGroup: EntropyGroup, liqee: EntropyAccount, perpMarket: PerpMarket, payer: Account | WalletAdapter, limitPerInstruction: number): Promise<TransactionSignature>;
    forceCancelPerpOrders(entropyGroup: EntropyGroup, liqeeEntropyAccount: EntropyAccount, perpMarket: PerpMarket, payer: Account, limit: BN): Promise<string>;
    liquidateTokenAndToken(entropyGroup: EntropyGroup, liqeeEntropyAccount: EntropyAccount, liqorEntropyAccount: EntropyAccount, assetRootBank: RootBank, liabRootBank: RootBank, payer: Account, maxLiabTransfer: I80F48): Promise<string>;
    liquidateTokenAndPerp(entropyGroup: EntropyGroup, liqeeEntropyAccount: EntropyAccount, liqorEntropyAccount: EntropyAccount, rootBank: RootBank, payer: Account, assetType: AssetType, assetIndex: number, liabType: AssetType, liabIndex: number, maxLiabTransfer: I80F48): Promise<string>;
    liquidatePerpMarket(entropyGroup: EntropyGroup, liqeeEntropyAccount: EntropyAccount, liqorEntropyAccount: EntropyAccount, perpMarket: PerpMarket, payer: Account, baseTransferRequest: BN): Promise<string>;
    settleFees(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, perpMarket: PerpMarket, rootBank: RootBank, payer: Account): Promise<string>;
    resolvePerpBankruptcy(entropyGroup: EntropyGroup, liqeeEntropyAccount: EntropyAccount, liqorEntropyAccount: EntropyAccount, perpMarket: PerpMarket, rootBank: RootBank, payer: Account, liabIndex: number, maxLiabTransfer: I80F48): Promise<string>;
    resolveTokenBankruptcy(entropyGroup: EntropyGroup, liqeeEntropyAccount: EntropyAccount, liqorEntropyAccount: EntropyAccount, quoteRootBank: RootBank, liabRootBank: RootBank, payer: Account, maxLiabTransfer: I80F48): Promise<string>;
    redeemMngo(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, perpMarket: PerpMarket, payer: Account | WalletAdapter, mngoRootBank: PublicKey, mngoNodeBank: PublicKey, mngoVault: PublicKey): Promise<TransactionSignature>;
    redeemAllMngo(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, payer: Account | WalletAdapter, mngoRootBank: PublicKey, mngoNodeBank: PublicKey, mngoVault: PublicKey): Promise<TransactionSignature>;
    addEntropyAccountInfo(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, owner: Account | WalletAdapter, info: string): Promise<TransactionSignature>;
    depositMsrm(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, owner: Account | WalletAdapter, msrmAccount: PublicKey, quantity: number): Promise<TransactionSignature>;
    withdrawMsrm(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, owner: Account | WalletAdapter, msrmAccount: PublicKey, quantity: number): Promise<TransactionSignature>;
    changePerpMarketParams(entropyGroup: EntropyGroup, perpMarket: PerpMarket, admin: Account | WalletAdapter, maintLeverage: number | undefined, initLeverage: number | undefined, liquidationFee: number | undefined, makerFee: number | undefined, takerFee: number | undefined, rate: number | undefined, maxDepthBps: number | undefined, targetPeriodLength: number | undefined, mngoPerPeriod: number | undefined, exp: number | undefined): Promise<TransactionSignature>;
    changePerpMarketParams2(entropyGroup: EntropyGroup, perpMarket: PerpMarket, admin: Account | WalletAdapter, maintLeverage: number | undefined, initLeverage: number | undefined, liquidationFee: number | undefined, makerFee: number | undefined, takerFee: number | undefined, rate: number | undefined, maxDepthBps: number | undefined, targetPeriodLength: number | undefined, mngoPerPeriod: number | undefined, exp: number | undefined, version: number | undefined, lmSizeShift: number | undefined): Promise<TransactionSignature>;
    setGroupAdmin(entropyGroup: EntropyGroup, newAdmin: PublicKey, admin: Account | WalletAdapter): Promise<TransactionSignature>;
    /**
     * Add allowance for orders to be cancelled and replaced in a single transaction
     */
    modifySpotOrder(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, entropyCache: PublicKey, spotMarket: Market, owner: Account | WalletAdapter, order: Order, side: 'buy' | 'sell', price: number, size: number, orderType?: 'limit' | 'ioc' | 'postOnly'): Promise<TransactionSignature>;
    modifyPerpOrder(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, entropyCache: PublicKey, perpMarket: PerpMarket, owner: Account | WalletAdapter, order: PerpOrder, side: 'buy' | 'sell', price: number, quantity: number, orderType?: PerpOrderType, clientOrderId?: number, bookSideInfo?: AccountInfo<Buffer>, // ask if side === bid, bids if side === ask; if this is given; crank instruction is added
    invalidIdOk?: boolean): Promise<TransactionSignature>;
    addPerpTriggerOrder(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, perpMarket: PerpMarket, owner: Account | WalletAdapter, orderType: PerpOrderType, side: 'buy' | 'sell', price: number, quantity: number, triggerCondition: 'above' | 'below', triggerPrice: number, reduceOnly: boolean, clientOrderId?: number): Promise<TransactionSignature>;
    removeAdvancedOrder(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, owner: Account | WalletAdapter, orderIndex: number): Promise<TransactionSignature>;
    executePerpTriggerOrder(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, entropyCache: EntropyCache, perpMarket: PerpMarket, payer: Account | WalletAdapter, orderIndex: number): Promise<TransactionSignature>;
    updateMarginBasket(entropyGroup: EntropyGroup, entropyAccount: EntropyAccount, payer: Account | WalletAdapter): Promise<string>;
}
//# sourceMappingURL=client.d.ts.map