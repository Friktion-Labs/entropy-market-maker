"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processConsumeEvents = exports.runKeeper = void 0;
/**
This will probably move to its own repo at some point but easier to keep it here for now
 */
const os = __importStar(require("os"));
const fs = __importStar(require("fs"));
const client_1 = require("./client");
const web3_js_1 = require("@solana/web3.js");
const utils_1 = require("./utils");
const ids_json_1 = __importDefault(require("./ids.json"));
const exampleConfig_json_1 = __importDefault(require("./exampleConfig.json"));
const config_1 = require("./config");
const instruction_1 = require("./instruction");
const bn_js_1 = __importDefault(require("bn.js"));
const layout_1 = require("./layout");
const _1 = require(".");
const PerpEventQueue_1 = __importDefault(require("./PerpEventQueue"));
const yargs_1 = __importDefault(require("yargs/yargs"));
const helpers_1 = require("yargs/helpers");
require('dotenv').config({ path: '.env' });
console.log(process.argv);
let keeperConfigRegistry;
if (process.argv[3]) {
    let keeperConfigRaw = fs.readFileSync(process.argv[3]);
    keeperConfigRegistry = JSON.parse(keeperConfigRaw.toString());
}
else {
    keeperConfigRegistry = exampleConfig_json_1.default;
}
console.log(keeperConfigRegistry);
let lastRootBankCacheUpdate = 0;
const groupName = process.env.GROUP || 'mainnet.2';
const cluster = (process.env.CLUSTER || 'mainnet');
const config = new config_1.Config(ids_json_1.default);
const groupIds = config.getGroup(cluster, groupName);
if (!groupIds) {
    throw new Error(`Group ${groupName} not found`);
}
let keeperConfigName = process.argv[4] || 'serum';
let keeperConfig = keeperConfigRegistry.find((x) => x.name == keeperConfigName);
const RPC_ENDPOINT = keeperConfig.rpc_endpoint || config.cluster_urls[cluster];
console.log('RPC_ENDPOINT USED', RPC_ENDPOINT);
const updateCacheInterval = parseInt(keeperConfig.update_cache_interval);
const updateRootBankCacheInterval = parseInt(keeperConfig.update_root_bank_cache_interval);
const processKeeperInterval = parseInt(keeperConfig.process_keeper_interval);
const consumeEventsInterval = parseInt(keeperConfig.consume_events_interval);
const maxUniqueAccounts = parseInt(keeperConfig.max_unique_accounts);
const consumeEventsLimit = new bn_js_1.default(keeperConfig.consume_events_limit);
const consumeEvents = true;
const entropyProgramId = groupIds.entropyProgramId;
const entropyGroupKey = groupIds.publicKey;
const payerJsonFile = fs.readFileSync(process.env.KEYPAIR ||
    os.homedir() + '/.config/solana/entropy-mainnet-authority.json', 'utf-8');
const payer = new web3_js_1.Account(JSON.parse(payerJsonFile));
const connection = new web3_js_1.Connection(RPC_ENDPOINT, 'confirmed');
const client = new client_1.EntropyClient(connection, entropyProgramId, { timeout: 10000 });
function runKeeper(shouldRun = 0) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log('shouldRun: ', shouldRun);
        if (shouldRun != 1) {
            return;
        }
        if (!groupIds) {
            throw new Error(`Group ${groupName} not found`);
        }
        const entropyGroup = yield client.getEntropyGroup(entropyGroupKey);
        const perpMarkets = yield Promise.all(groupIds.perpMarkets.map((m) => {
            return entropyGroup.loadPerpMarket(connection, m.marketIndex, m.baseDecimals, m.quoteDecimals);
        }));
        processUpdateCache(entropyGroup);
        processKeeperTransactions(entropyGroup, perpMarkets);
        if (consumeEvents) {
            processConsumeEvents(entropyGroup, perpMarkets);
        }
    });
}
exports.runKeeper = runKeeper;
console.time('processUpdateCache');
function processUpdateCache(entropyGroup) {
    return __awaiter(this, void 0, void 0, function* () {
        console.timeEnd('processUpdateCache');
        try {
            const batchSize = 8;
            let promises = [];
            const rootBanks = entropyGroup.tokens
                .map((t) => t.rootBank)
                .filter((t) => !t.equals(utils_1.zeroKey));
            const oracles = entropyGroup.oracles.filter((o) => !o.equals(utils_1.zeroKey));
            const perpMarkets = entropyGroup.perpMarkets
                .filter((pm) => !pm.isEmpty())
                .map((pm) => pm.perpMarket);
            const nowTs = Date.now();
            let shouldUpdateRootBankCache = false;
            if (nowTs - lastRootBankCacheUpdate > updateRootBankCacheInterval) {
                shouldUpdateRootBankCache = true;
                lastRootBankCacheUpdate = nowTs;
            }
            for (let i = 0; i < rootBanks.length / batchSize; i++) {
                const startIndex = i * batchSize;
                const endIndex = i * batchSize + batchSize;
                const cacheTransaction = new web3_js_1.Transaction();
                if (shouldUpdateRootBankCache) {
                    cacheTransaction.add((0, instruction_1.makeCacheRootBankInstruction)(entropyProgramId, entropyGroup.publicKey, entropyGroup.entropyCache, rootBanks.slice(startIndex, endIndex)));
                }
                if (cacheTransaction.instructions.length > 0) {
                    promises.push(client.sendTransaction(cacheTransaction, payer, []));
                }
            }
            Promise.all(promises).catch((err) => {
                console.error('Error updating cache', err);
            });
            promises = [];
            for (let i = 0; i < oracles.length / batchSize; i++) {
                const startIndex = i * batchSize;
                const endIndex = i * batchSize + batchSize;
                const cacheTransaction = new web3_js_1.Transaction();
                console.log('oracles: ', oracles.toString());
                cacheTransaction.add((0, instruction_1.makeCachePricesInstruction)(entropyProgramId, entropyGroup.publicKey, entropyGroup.entropyCache, oracles.slice(startIndex, endIndex)));
                cacheTransaction.add((0, instruction_1.makeCachePerpMarketsInstruction)(entropyProgramId, entropyGroup.publicKey, entropyGroup.entropyCache, perpMarkets.slice(startIndex, endIndex)));
                if (cacheTransaction.instructions.length > 0) {
                    promises.push(client.sendTransaction(cacheTransaction, payer, []));
                }
            }
            Promise.all(promises).catch((err) => {
                console.error('Error updating cache', err);
            });
        }
        finally {
            console.time('processUpdateCache');
            setTimeout(processUpdateCache, updateCacheInterval, entropyGroup);
        }
    });
}
function processConsumeEvents(entropyGroup, perpMarkets, customInterval = consumeEventsInterval) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const eventQueuePks = perpMarkets.map((mkt) => mkt.eventQueue);
            const eventQueueAccts = yield (0, utils_1.getMultipleAccounts)(connection, eventQueuePks);
            const perpMktAndEventQueue = eventQueueAccts.map(({ publicKey, accountInfo }) => {
                const parsed = layout_1.PerpEventQueueLayout.decode(accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data);
                const eventQueue = new PerpEventQueue_1.default(parsed);
                const perpMarket = perpMarkets.find((mkt) => mkt.eventQueue.equals(publicKey));
                if (!perpMarket) {
                    throw new Error('PerpMarket not found');
                }
                return { perpMarket, eventQueue };
            });
            const promises = perpMktAndEventQueue.map(({ perpMarket, eventQueue }) => {
                const events = eventQueue.getUnconsumedEvents();
                if (events.length === 0) {
                    // console.log('No events to consume');
                    return (0, _1.promiseUndef)();
                }
                const accounts = new Set();
                for (const event of events) {
                    if (event.fill) {
                        accounts.add(event.fill.maker.toBase58());
                        accounts.add(event.fill.taker.toBase58());
                    }
                    else if (event.out) {
                        accounts.add(event.out.owner.toBase58());
                    }
                    // Limit unique accounts to first 20 or 21
                    if (accounts.size >= maxUniqueAccounts) {
                        break;
                    }
                }
                return client
                    .consumeEvents(entropyGroup, perpMarket, Array.from(accounts)
                    .map((s) => new web3_js_1.PublicKey(s))
                    .sort(), payer, consumeEventsLimit)
                    .then(() => {
                    console.log(`Consumed up to ${events.length} events ${perpMarket.publicKey.toBase58()}`);
                    console.log('EVENTS:', events.map((e) => { var _a; return (_a = e === null || e === void 0 ? void 0 : e.fill) === null || _a === void 0 ? void 0 : _a.seqNum.toString(); }));
                })
                    .catch((err) => {
                    console.error('Error consuming events', err);
                });
            });
            Promise.all(promises);
        }
        finally {
            setTimeout(processConsumeEvents, customInterval, entropyGroup, perpMarkets);
        }
    });
}
exports.processConsumeEvents = processConsumeEvents;
function processKeeperTransactions(entropyGroup, perpMarkets) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (!groupIds) {
                throw new Error(`Group ${groupName} not found`);
            }
            console.log('processKeeperTransactions');
            const batchSize = 8;
            const promises = [];
            const filteredPerpMarkets = perpMarkets.filter((pm) => !pm.publicKey.equals(utils_1.zeroKey));
            for (let i = 0; i < groupIds.tokens.length / batchSize; i++) {
                const startIndex = i * batchSize;
                const endIndex = i * batchSize + batchSize;
                const updateRootBankTransaction = new web3_js_1.Transaction();
                groupIds.tokens.slice(startIndex, endIndex).forEach((token) => {
                    updateRootBankTransaction.add((0, instruction_1.makeUpdateRootBankInstruction)(entropyProgramId, entropyGroup.publicKey, entropyGroup.entropyCache, token.rootKey, token.nodeKeys));
                });
                const updateFundingTransaction = new web3_js_1.Transaction();
                filteredPerpMarkets.slice(startIndex, endIndex).forEach((market) => {
                    if (market) {
                        updateFundingTransaction.add((0, instruction_1.makeUpdateFundingInstruction)(entropyProgramId, entropyGroup.publicKey, entropyGroup.entropyCache, market.publicKey, market.bids, market.asks));
                    }
                });
                if (updateRootBankTransaction.instructions.length > 0) {
                    promises.push(client.sendTransaction(updateRootBankTransaction, payer, []));
                }
                if (updateFundingTransaction.instructions.length > 0) {
                    promises.push(client.sendTransaction(updateFundingTransaction, payer, []));
                }
            }
            Promise.all(promises).catch((err) => {
                console.error('Error processing keeper instructions', err);
            });
        }
        finally {
            setTimeout(processKeeperTransactions, processKeeperInterval, entropyGroup, perpMarkets);
        }
    });
}
(0, yargs_1.default)((0, helpers_1.hideBin)(process.argv)).command('run', 'runs the keeper', (y) => {
    return;
}, (args) => __awaiter(void 0, void 0, void 0, function* () {
    console.log('Running keeper via args');
    runKeeper(1);
})).argv;
//# sourceMappingURL=keeper.js.map