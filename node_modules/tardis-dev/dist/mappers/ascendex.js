"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AscendexBookTickerMapper = exports.AscendexDerivativeTickerMapper = exports.AscendexBookChangeMapper = exports.AscendexTradesMapper = void 0;
const handy_1 = require("../handy");
const mapper_1 = require("./mapper");
class AscendexTradesMapper {
    canHandle(message) {
        return message.m === 'trades';
    }
    getFilters(symbols) {
        symbols = (0, handy_1.upperCaseSymbols)(symbols);
        return [
            {
                channel: 'trades',
                symbols
            }
        ];
    }
    *map(message, localTimestamp) {
        for (let trade of message.data) {
            yield {
                type: 'trade',
                symbol: message.symbol,
                exchange: 'ascendex',
                id: undefined,
                price: Number(trade.p),
                amount: Number(trade.q),
                side: trade.bm === true ? 'sell' : 'buy',
                timestamp: new Date(trade.ts),
                localTimestamp: localTimestamp
            };
        }
    }
}
exports.AscendexTradesMapper = AscendexTradesMapper;
class AscendexBookChangeMapper {
    canHandle(message) {
        return message.m === 'depth-realtime' || message.m === 'depth-snapshot-realtime';
    }
    getFilters(symbols) {
        symbols = (0, handy_1.upperCaseSymbols)(symbols);
        return [
            {
                channel: 'depth-realtime',
                symbols
            },
            {
                channel: 'depth-snapshot-realtime',
                symbols
            }
        ];
    }
    *map(message, localTimestamp) {
        yield {
            type: 'book_change',
            symbol: message.symbol,
            exchange: 'ascendex',
            isSnapshot: message.m === 'depth-snapshot-realtime',
            bids: message.data.bids.map(this.mapBookLevel),
            asks: message.data.asks.map(this.mapBookLevel),
            timestamp: message.data.ts > 0 ? new Date(message.data.ts) : localTimestamp,
            localTimestamp
        };
    }
    mapBookLevel(level) {
        const price = Number(level[0]);
        const amount = Number(level[1]);
        return { price, amount };
    }
}
exports.AscendexBookChangeMapper = AscendexBookChangeMapper;
class AscendexDerivativeTickerMapper {
    constructor() {
        this.pendingTickerInfoHelper = new mapper_1.PendingTickerInfoHelper();
    }
    canHandle(message) {
        return message.m === 'futures-pricing-data' || message.m === 'trades';
    }
    getFilters(symbols) {
        symbols = (0, handy_1.upperCaseSymbols)(symbols);
        return [
            {
                channel: 'futures-pricing-data',
                symbols: []
            },
            {
                channel: 'trades',
                symbols
            }
        ];
    }
    *map(message, localTimestamp) {
        if (message.m === 'trades') {
            const pendingTickerInfo = this.pendingTickerInfoHelper.getPendingTickerInfo(message.symbol, 'ascendex');
            pendingTickerInfo.updateLastPrice(Number(message.data[message.data.length - 1].p));
            return;
        }
        for (const futuresData of message.con) {
            const pendingTickerInfo = this.pendingTickerInfoHelper.getPendingTickerInfo(futuresData.s, 'ascendex');
            pendingTickerInfo.updateIndexPrice(Number(futuresData.ip));
            pendingTickerInfo.updateMarkPrice(Number(futuresData.mp));
            pendingTickerInfo.updateOpenInterest(Number(futuresData.oi));
            pendingTickerInfo.updateTimestamp(new Date(futuresData.t));
            pendingTickerInfo.updateFundingTimestamp(new Date(futuresData.f));
            pendingTickerInfo.updateFundingRate(Number(futuresData.r));
            if (pendingTickerInfo.hasChanged()) {
                yield pendingTickerInfo.getSnapshot(localTimestamp);
            }
        }
    }
}
exports.AscendexDerivativeTickerMapper = AscendexDerivativeTickerMapper;
class AscendexBookTickerMapper {
    canHandle(message) {
        return message.m === 'bbo';
    }
    getFilters(symbols) {
        symbols = (0, handy_1.upperCaseSymbols)(symbols);
        return [
            {
                channel: 'bbo',
                symbols
            }
        ];
    }
    *map(message, localTimestamp) {
        const ask = message.data.ask;
        const bid = message.data.bid;
        yield {
            type: 'book_ticker',
            symbol: message.symbol,
            exchange: 'ascendex',
            askAmount: ask !== undefined && ask[1] !== undefined ? Number(ask[1]) : undefined,
            askPrice: ask !== undefined && ask[0] !== undefined ? Number(ask[0]) : undefined,
            bidPrice: bid !== undefined && bid[0] !== undefined ? Number(bid[0]) : undefined,
            bidAmount: bid !== undefined && bid[1] !== undefined ? Number(bid[1]) : undefined,
            timestamp: new Date(message.data.ts),
            localTimestamp: localTimestamp
        };
    }
}
exports.AscendexBookTickerMapper = AscendexBookTickerMapper;
//# sourceMappingURL=ascendex.js.map