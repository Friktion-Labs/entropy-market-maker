"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SerumBookTickerMapper = exports.SerumBookChangeMapper = exports.SerumTradesMapper = void 0;
const handy_1 = require("../handy");
class SerumTradesMapper {
    constructor(_exchange) {
        this._exchange = _exchange;
    }
    canHandle(message) {
        return message.type === 'trade';
    }
    getFilters(symbols) {
        if (this._exchange === 'serum') {
            symbols = (0, handy_1.upperCaseSymbols)(symbols);
        }
        return [
            {
                channel: 'trade',
                symbols
            }
        ];
    }
    *map(message, localTimestamp) {
        yield {
            type: 'trade',
            symbol: message.market.toUpperCase(),
            exchange: this._exchange,
            id: message.id,
            price: Number(message.price),
            amount: Number(message.size),
            side: message.side,
            timestamp: new Date(message.timestamp),
            localTimestamp: localTimestamp
        };
    }
}
exports.SerumTradesMapper = SerumTradesMapper;
class SerumBookChangeMapper {
    constructor(_exchange) {
        this._exchange = _exchange;
    }
    canHandle(message) {
        return message.type === 'l2snapshot' || message.type === 'l2update';
    }
    getFilters(symbols) {
        if (this._exchange === 'serum') {
            symbols = (0, handy_1.upperCaseSymbols)(symbols);
        }
        return [
            {
                channel: 'l2snapshot',
                symbols
            },
            {
                channel: 'l2update',
                symbols
            }
        ];
    }
    *map(message, localTimestamp) {
        yield {
            type: 'book_change',
            symbol: message.market.toUpperCase(),
            exchange: this._exchange,
            isSnapshot: message.type === 'l2snapshot',
            bids: message.bids.map(this.mapBookLevel),
            asks: message.asks.map(this.mapBookLevel),
            timestamp: new Date(message.timestamp),
            localTimestamp
        };
    }
    mapBookLevel(level) {
        const price = Number(level[0]);
        const amount = Number(level[1]);
        return { price, amount };
    }
}
exports.SerumBookChangeMapper = SerumBookChangeMapper;
class SerumBookTickerMapper {
    constructor(_exchange) {
        this._exchange = _exchange;
    }
    canHandle(message) {
        return message.type === 'quote';
    }
    getFilters(symbols) {
        if (this._exchange === 'serum') {
            symbols = (0, handy_1.upperCaseSymbols)(symbols);
        }
        return [
            {
                channel: 'quote',
                symbols
            }
        ];
    }
    *map(message, localTimestamp) {
        yield {
            type: 'book_ticker',
            symbol: message.market.toUpperCase(),
            exchange: this._exchange,
            askAmount: message.bestAsk !== undefined ? (0, handy_1.asNumberIfValid)(message.bestAsk[1]) : undefined,
            askPrice: message.bestAsk !== undefined ? (0, handy_1.asNumberIfValid)(message.bestAsk[0]) : undefined,
            bidPrice: message.bestBid !== undefined ? (0, handy_1.asNumberIfValid)(message.bestBid[0]) : undefined,
            bidAmount: message.bestBid !== undefined ? (0, handy_1.asNumberIfValid)(message.bestBid[1]) : undefined,
            timestamp: new Date(message.timestamp),
            localTimestamp: localTimestamp
        };
    }
}
exports.SerumBookTickerMapper = SerumBookTickerMapper;
//# sourceMappingURL=serum.js.map